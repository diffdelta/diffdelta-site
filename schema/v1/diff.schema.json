{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://diffdelta.io/schema/v1/diff.schema.json",
  "title": "DiffDelta Diff Feed (v1) - Phase 1: Substrate Lockdown",
  "oneOf": [
    {
      "title": "Global Feed",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "batch_narrative",
        "schema_version",
        "generated_at",
        "cursor",
        "prev_cursor",
        "changed",
        "ttl_sec",
        "sources_included",
        "sources",
        "buckets"
      ],
      "properties": {
        "batch_narrative": { 
          "type": "string", 
          "minLength": 1,
          "maxLength": 500,
          "description": "Human-readable summary of batch changes (max 30 words per SPEC.md)"
        },
        "schema_version": { "type": "string", "pattern": "^1\\.[0-9]+\\.[0-9]+$", "description": "Schema version. Breaking changes increment minor version (e.g., 1.0.0 -> 1.1.0)" },
        "generated_at": { "type": "string", "format": "date-time" },

        "cursor": { 
          "type": "string", 
          "minLength": 1,
          "maxLength": 200,
          "description": "Hash-based deterministic cursor (format: sha256:<64-char-hex>). Hash of canonical batch payload excluding volatile fields. See cursor_basis for canonicalization rules."
        },
        "prev_cursor": { 
          "type": "string", 
          "minLength": 1,
          "maxLength": 200,
          "description": "Previous hash-based cursor (format: sha256:<64-char-hex>). See cursor_basis for canonicalization rules."
        },
        "cursor_basis": {
          "type": "string",
          "description": "Specifies the canonicalization method for cursor computation. Format: 'canonical_v1' indicates cursor is hash of canonical batch payload EXCLUDING volatile fields (generated_at, etc.). Rule: cursor MUST NOT include generated_at or other timestamps - rerunning engine without changes MUST produce identical cursor. hash field represents the file as stored (including generated_at). See schema docs for exact canonicalization rules."
        },
        "hash": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "description": "SHA-256 hash of the file as stored (including generated_at and other volatile fields). Format: sha256:<64-char-hex>. Differs from cursor which uses canonicalized payload."
        },
        "prev_hash": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "description": "Previous hash value from previous latest.json (file as stored). Format: sha256:<64-char-hex>"
        },
        "changed": { 
          "type": "boolean",
          "description": "True if any source changed (i.e., counts.new > 0 or counts.updated > 0 or counts.removed > 0). Contract: when true, top-level cursor MUST differ from prev_cursor. When false, cursor MUST equal prev_cursor."
        },
        "ttl_sec": { "type": "integer", "minimum": 15, "maximum": 3600 },
        "integrity_reset": {
          "type": "boolean",
          "description": "True if chain integrity was broken/reset (missing or corrupted previous latest.json)"
        },
        "integrity_risk": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Risk score (0.0-1.0) indicating integrity concerns. 0.2 if integrity_reset is true, 0.0 otherwise"
        },
        "impact": {
          "type": "string",
          "enum": ["low", "high"],
          "description": "Overall impact level of batch changes (Phase B, optional). 'low' for boilerplate/timestamp-only changes, 'high' for substantive content changes. Allows bots to subscribe to high-impact only."
        },
        "impact_reason": {
          "type": "string",
          "enum": ["boilerplate_only", "title_only", "minor_edit", "timestamp_only", "metadata_only", "substantive"],
          "description": "Reason for batch impact classification (optional). Helps bots understand why byte-level changes occurred."
        },

        "sources_included": {
          "type": "array",
          "minItems": 1,
          "uniqueItems": true,
          "items": { "type": "string", "pattern": "^[a-z0-9_\\-]{2,32}$" },
          "description": "List of source IDs included in this batch. MUST be sorted alphabetically for deterministic cursor computation."
        },

        "sources": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/sourceStatus" },
          "description": "Per-source status object. When serialized for cursor computation, MUST use canonical JSON ordering (keys sorted alphabetically) to ensure deterministic hashing."
        },

        "buckets": {
          "type": "object",
          "additionalProperties": true,
          "required": ["new", "updated", "removed", "flagged"],
          "description": "Item buckets. Arrays MUST be sorted deterministically (e.g., by published_at, then source, then id) for stable cursor computation. Same semantic content MUST produce identical cursor. Extensibility: clients MUST treat missing bucket arrays as empty arrays. Clients MAY ignore unknown bucket types for forward compatibility.",
          "properties": {
            "new": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } },
            "updated": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } },
            "removed": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } },
            "flagged": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } }
          }
        }
      }
    },
    {
      "title": "Per-Source Feed",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "batch_narrative",
        "schema_version",
        "generated_at",
        "cursor",
        "prev_cursor",
        "changed",
        "ttl_sec",
        "sources_included",
        "sources",
        "buckets",
        "source_id",
        "status"
      ],
      "properties": {
        "batch_narrative": { 
          "type": "string", 
          "minLength": 1,
          "maxLength": 500,
          "description": "Human-readable summary of batch changes (max 30 words per SPEC.md)"
        },
        "schema_version": { "type": "string", "pattern": "^1\\.[0-9]+\\.[0-9]+$", "description": "Schema version. Breaking changes increment minor version (e.g., 1.0.0 -> 1.1.0)" },
        "generated_at": { "type": "string", "format": "date-time" },

        "cursor": { 
          "type": "string", 
          "minLength": 1,
          "maxLength": 200,
          "description": "Hash-based deterministic cursor (format: sha256:<64-char-hex>). Hash of canonical batch payload excluding volatile fields. See cursor_basis for canonicalization rules."
        },
        "prev_cursor": { 
          "type": "string", 
          "minLength": 1,
          "maxLength": 200,
          "description": "Previous hash-based cursor (format: sha256:<64-char-hex>). See cursor_basis for canonicalization rules."
        },
        "cursor_basis": {
          "type": "string",
          "description": "Specifies the canonicalization method for cursor computation. Format: 'canonical_v1' indicates cursor is hash of canonical batch payload EXCLUDING volatile fields (generated_at, etc.). Rule: cursor MUST NOT include generated_at or other timestamps - rerunning engine without changes MUST produce identical cursor. hash field represents the file as stored (including generated_at). See schema docs for exact canonicalization rules."
        },
        "hash": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "description": "SHA-256 hash of the file as stored (including generated_at and other volatile fields). Format: sha256:<64-char-hex>. Differs from cursor which uses canonicalized payload."
        },
        "prev_hash": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "description": "Previous hash value from previous latest.json (file as stored). Format: sha256:<64-char-hex>"
        },
        "changed": { 
          "type": "boolean",
          "description": "True if any source changed (i.e., counts.new > 0 or counts.updated > 0 or counts.removed > 0). Contract: when true, top-level cursor MUST differ from prev_cursor. When false, cursor MUST equal prev_cursor."
        },
        "ttl_sec": { "type": "integer", "minimum": 15, "maximum": 3600 },
        "integrity_reset": {
          "type": "boolean",
          "description": "True if chain integrity was broken/reset (missing or corrupted previous latest.json)"
        },
        "integrity_risk": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Risk score (0.0-1.0) indicating integrity concerns. 0.2 if integrity_reset is true, 0.0 otherwise"
        },
        "impact": {
          "type": "string",
          "enum": ["low", "high"],
          "description": "Overall impact level of batch changes (Phase B, optional). 'low' for boilerplate/timestamp-only changes, 'high' for substantive content changes. Allows bots to subscribe to high-impact only."
        },
        "impact_reason": {
          "type": "string",
          "enum": ["boilerplate_only", "title_only", "minor_edit", "timestamp_only", "metadata_only", "substantive"],
          "description": "Reason for batch impact classification (optional). Helps bots understand why byte-level changes occurred."
        },

        "sources_included": {
          "type": "array",
          "minItems": 1,
          "uniqueItems": true,
          "items": { "type": "string", "pattern": "^[a-z0-9_\\-]{2,32}$" },
          "description": "List of source IDs included in this batch. MUST be sorted alphabetically for deterministic cursor computation."
        },

        "sources": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/sourceStatus" },
          "description": "Per-source status object. When serialized for cursor computation, MUST use canonical JSON ordering (keys sorted alphabetically) to ensure deterministic hashing."
        },

        "buckets": {
          "type": "object",
          "additionalProperties": true,
          "required": ["new", "updated", "removed", "flagged"],
          "description": "Item buckets. Arrays MUST be sorted deterministically (e.g., by published_at, then source, then id) for stable cursor computation. Same semantic content MUST produce identical cursor. Extensibility: clients MUST treat missing bucket arrays as empty arrays. Clients MAY ignore unknown bucket types for forward compatibility.",
          "properties": {
            "new": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } },
            "updated": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } },
            "removed": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } },
            "flagged": { "type": "array", "items": { "$ref": "#/$defs/deltaItem" } }
          }
        },
        
        "source_id": {
          "type": "string",
          "pattern": "^[a-z0-9_\\-]{2,32}$",
          "description": "Source identifier (required in per-source feeds)"
        },
        
        "status": {
          "type": "string",
          "enum": ["ok", "error", "disabled"],
          "description": "Source status (required in per-source feeds)"
        }
      }
    }
  ],

  "$defs": {
    "sourceStatus": {
      "type": "object",
      "additionalProperties": false,
      "required": ["changed", "cursor", "prev_cursor", "ttl_sec", "status"],
      "properties": {
        "changed": { 
          "type": "boolean",
          "description": "True if source content changed at byte level since last cursor (hash-based detection). Contract: when true, MUST have either (1) items in buckets with matching source ID, OR (2) delta_counts provided. If changed:true but all delta_counts are zero, MUST provide impact_reason."
        },
        "cursor": { 
          "type": "string", 
          "minLength": 1, 
          "maxLength": 200,
          "description": "Hash-based cursor. For error/disabled sources, MUST be the last-known-good cursor (not zero cursor) to preserve continuity."
        },
        "prev_cursor": { 
          "type": "string", 
          "minLength": 1, 
          "maxLength": 200,
          "description": "Previous cursor. For error/disabled sources, MUST be the last-known-good cursor (not zero cursor) to preserve continuity."
        },
        "ttl_sec": { "type": "integer", "minimum": 15, "maximum": 3600 },
        "status": {
          "type": "string",
          "enum": ["ok", "error", "disabled"]
        },
        "stale": {
          "type": "boolean",
          "description": "True if source is disabled or in error state. Indicates data may be outdated."
        },
        "stale_age_sec": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of seconds since last successful fetch (last_ok_at). Present when stale is true. Helps bots decide: ignore, alert, or fallback to alternate mirrors."
        },
        "last_ok_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp of last successful fetch. Present when stale is true."
        },
        "delta_counts": {
          "type": "object",
          "additionalProperties": false,
          "description": "Count of items changed per source. Present when changed is true to help bots decide which sources to fetch deeper details for.",
          "required": ["new", "updated", "removed"],
          "properties": {
            "new": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of new items from this source"
            },
            "updated": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of updated items from this source"
            },
            "removed": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of removed items from this source"
            }
          }
        },
        "signal_coverage": {
          "type": "number",
          "minimum": 0,
          "maximum": 100,
          "description": "Percentage of items from this source that have structured signals (0-100). Present only when changed:true and source has items in current batch. Source-type dependent: security sources (CISA KEV, GitHub Advisories) typically have 100% coverage; blog/news sources may have 0%. Bots can use this to calibrate trust in flagged:0 for this specific source."
        },
        "impact": {
          "type": "string",
          "enum": ["low", "high"],
          "description": "Impact level of changes (Phase B). 'low' for boilerplate/timestamp-only changes, 'high' for substantive content changes. Allows bots to subscribe to high-impact only without ignoring byte-level changes."
        },
        "impact_reason": {
          "type": "string",
          "enum": ["boilerplate_only", "title_only", "minor_edit", "timestamp_only", "metadata_only", "substantive"],
          "description": "Reason for impact classification. Required when changed:true but all delta_counts are zero. Helps bots understand why byte-level changes occurred without item-level deltas."
        },
        "error": {
          "type": "object",
          "additionalProperties": false,
          "description": "Error details if status is 'error'",
          "properties": {
            "code": {
              "type": "string",
              "description": "Error code (e.g., 'HTTP_403', 'HTTP_500', 'TIMEOUT', 'NETWORK_ERROR')"
            },
            "http_status": {
              "type": "integer",
              "minimum": 100,
              "maximum": 599,
              "description": "HTTP status code if error was from HTTP request"
            }
          },
          "required": ["code"]
        }
      }
    },

    "deltaItem": {
      "type": "object",
      "additionalProperties": true,
      "required": ["source", "id", "url", "published_at", "updated_at", "headline", "content", "risk", "provenance"],
      "properties": {
        "source": { "type": "string", "pattern": "^[a-z0-9_\\-]{2,32}$" },
        "id": { "type": "string", "minLength": 1, "maxLength": 200 },
        "url": { "type": "string", "format": "uri" },

        "title": { "type": "string", "maxLength": 200 },
        "published_at": { "type": "string", "format": "date-time" },
        "updated_at": { "type": "string", "format": "date-time" },

        "signals": {
          "type": "array",
          "maxItems": 10,
          "uniqueItems": true,
          "items": { "type": "string", "pattern": "^[a-z0-9_\\-]{2,32}$" }
        },

        "action_items": {
          "type": "array",
          "maxItems": 10,
          "items": { "$ref": "#/$defs/actionItem" }
        },

        "headline": {
          "type": "string",
          "minLength": 1,
          "maxLength": 2000,
          "description": "Deterministic title-like field derived from source (RSS title, etc.). Not an LLM summary."
        },
        
        "summary": {
          "type": "string",
          "minLength": 1,
          "maxLength": 2000,
          "description": "Optional LLM-generated summary (pre-chewed content). Can be absent or 'pending' if not yet generated."
        },
        
        "content": {
          "type": "object",
          "additionalProperties": false,
          "required": ["lang"],
          "properties": {
            "excerpt_text": {
              "type": "string",
              "maxLength": 500,
              "description": "Plain text excerpt extracted from HTML for agents/diffing"
            },
            "lang": {
              "type": "string",
              "pattern": "^[a-z]{2,3}$",
              "description": "Language code: ISO 639-1 (2-letter, e.g., 'en', 'es') or 'und' (undetermined) when language cannot be confidently detected. Never use a confident label if uncertain; 'und' is safer than incorrect detection."
            }
          }
        },

        "risk": { "$ref": "#/$defs/risk" },
        "provenance": { "$ref": "#/$defs/provenance" },
        "item_hash": {
          "type": "string",
          "pattern": "^sha256:[a-f0-9]{64}$",
          "description": "Deterministic hash for item deduplication: sha256(source_id + '|' + id + '|' + content_hash). Optional but recommended. Bots can use this as primary key for deduplication across sources."
        },
        
        "source_payload": {
          "type": "object",
          "additionalProperties": true,
          "description": "Opaque raw upstream data from the source, preserved for debugging and traceability. HTML content is consolidated into 'html' field (removes duplicate description/summary)."
        }
      }
    },

    "actionItem": {
      "type": "object",
      "additionalProperties": false,
      "required": ["type", "text"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["investigate", "workaround", "fix_posted", "upgrade", "ignore", "monitor", "block"]
        },
        "text": { "type": "string", "minLength": 1, "maxLength": 280 },
        "url": { "type": "string", "format": "uri" }
      }
    },

    "risk": {
      "type": "object",
      "additionalProperties": false,
      "required": ["score"],
      "properties": {
        "score": { "type": "number", "minimum": 0, "maximum": 1 },
        "reasons": {
          "type": "array",
          "maxItems": 10,
          "items": { "type": "string", "pattern": "^[a-z0-9_\\-]{2,64}$" }
        }
      }
    },

    "provenance": {
      "type": "object",
      "additionalProperties": false,
      "required": ["fetched_at", "evidence_urls", "content_hash"],
      "properties": {
        "fetched_at": { "type": "string", "format": "date-time" },
        "evidence_urls": {
          "type": "array",
          "minItems": 1,
          "maxItems": 20,
          "items": { "type": "string", "format": "uri" }
        },
        "content_hash": {
          "type": "string",
          "pattern": "^sha256:[a-f0-9]{64}$",
          "description": "SHA256 hash of canonical content for integrity verification (prefixed with 'sha256:')"
        }
      }
    }
  }
}
