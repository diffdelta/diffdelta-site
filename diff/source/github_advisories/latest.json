{
  "schema_version": "1.2.0",
  "generated_at": "2026-02-25T19:58:11Z",
  "source_id": "github_advisories",
  "hash": "sha256:9424d85b69c59ae7955f80dfe8fe7d703177394bd550a0fb4cfb1931320c33e8",
  "prev_hash": "sha256:88828c985894b92c3432aa91547ef61c94fe1aeb23cd4835a315a38bb4ede40f",
  "cursor": "sha256:df92611b93932423c509d62fdcb80bffdc238934d171a835a8487837954d91e0",
  "prev_cursor": "sha256:e97e544dc954fb135f24006d234878e0b5cfbdf153c8c4706f06904285086ae4",
  "changed": true,
  "ttl_sec": 3600,
  "sources_included": [
    "github_advisories"
  ],
  "batch_narrative": "github_advisories: 100 advisories (11 critical, 33 high, 43 medium, 13 low).",
  "buckets": {
    "items": [
      {
        "source": "github_advisories",
        "id": "CVE-2026-25736",
        "url": "https://github.com/advisories/GHSA-fq4f-4738-rqxm",
        "published_at": "2026-02-25T19:37:27Z",
        "updated_at": "2026-02-25T19:37:27Z",
        "headline": "Rucio WebUI has a Stored Cross-site Scripting (XSS) Vulnerability in its Custom RSE Attribute",
        "content": {
          "excerpt_text": "### Summary A stored Cross-site Scripting (XSS) vulnerability was identified in the Custom RSE Attribute of the WebUI where attacker-controlled input is persisted by the backend and later rendered in the WebUI without proper output encoding. This allows arbitrary JavaScript execution in the context of the WebUI for users who view affected pages, potentially enabling session token theft or unauthorized actions. --- ### Details A stored XSS payload can be introduced via a custom RSE attribute...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-fq4f-4738-rqxm"
          ],
          "content_hash": "sha256:5ca82713d847383636714bff1bcb21e5d1f454cfe6ab51731454217a15eba0e1"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79",
              "CWE-1004"
            ],
            "packages": [
              "pip:rucio-webui",
              "pip:rucio-webui",
              "pip:rucio-webui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-fq4f-4738-rqxm"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25735",
        "url": "https://github.com/advisories/GHSA-8wpv-6x3f-3rm5",
        "published_at": "2026-02-25T19:29:37Z",
        "updated_at": "2026-02-25T19:41:59Z",
        "headline": "Rucio WebUI has a Stored Cross-site Scripting (XSS) vulnerability its Identity Name",
        "content": {
          "excerpt_text": "### Summary A stored Cross-site Scripting (XSS) vulnerability was identified in the Identity Name of the WebUI where attacker-controlled input is persisted by the backend and later rendered in the WebUI without proper output encoding. This allows arbitrary JavaScript execution in the context of the WebUI for users who view affected pages, potentially enabling session token theft or unauthorized actions. --- ### Details The identity name is stored and later rendered without output encoding....",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-8wpv-6x3f-3rm5"
          ],
          "content_hash": "sha256:79235d266c5495abccee71be2c42fb47a874abc1fb765ffbeaca11e12f3a4232"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79",
              "CWE-1004"
            ],
            "packages": [
              "pip:rucio-webui",
              "pip:rucio-webui",
              "pip:rucio-webui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-8wpv-6x3f-3rm5"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25734",
        "url": "https://github.com/advisories/GHSA-h9fp-p2p9-873q",
        "published_at": "2026-02-25T19:29:22Z",
        "updated_at": "2026-02-25T19:29:23Z",
        "headline": "Rucio WebUI has Stored Cross-site Scripting (XSS) in RSE Metadata",
        "content": {
          "excerpt_text": "### Summary A stored Cross-site Scripting (XSS) vulnerability was identified in the RSE metadata of the WebUI where attacker-controlled input is persisted by the backend and later rendered in the WebUI without proper output encoding. This allows arbitrary JavaScript execution in the context of the WebUI for users who view affected pages, potentially enabling session token theft or unauthorized actions. --- ### Details Several metadata fields accept arbitrary input which is stored and later...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-h9fp-p2p9-873q"
          ],
          "content_hash": "sha256:fe950f2a7b4fc71ece8841a32b9ea55511c0e48e0c61ff997475dfef093b2964"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79",
              "CWE-1004"
            ],
            "packages": [
              "pip:rucio-webui",
              "pip:rucio-webui",
              "pip:rucio-webui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-h9fp-p2p9-873q"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-3105",
        "url": "https://github.com/advisories/GHSA-r5j5-q42h-fc93",
        "published_at": "2026-02-25T19:28:39Z",
        "updated_at": "2026-02-25T19:28:40Z",
        "headline": "Mautic is Vulnerable to SQL Injection through Contact Activity API Sorting",
        "content": {
          "excerpt_text": "### Summary This advisory addresses a SQL Injection vulnerability in the API endpoint used for retrieving contact activities. A vulnerability exists in the query construction for the Contact Activity timeline where the parameter responsible for determining the sort direction was not strictly validated against an allowlist, potentially allowing authenticated users to inject arbitrary SQL commands via the API. ### Mitigation Please update to **5.2.10**, **6.0.8**, **7.0.1** or later. ###...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-r5j5-q42h-fc93"
          ],
          "content_hash": "sha256:0844c98eb427607d1ac4353a686a92fb08f73e1bd865ec383175a5cd43a2d0f8"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.6,
            "cwes": [
              "CWE-89"
            ],
            "packages": [
              "composer:mautic/core",
              "composer:mautic/core",
              "composer:mautic/core"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-r5j5-q42h-fc93"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27799",
        "url": "https://github.com/advisories/GHSA-r99p-5442-q2x2",
        "published_at": "2026-02-25T19:24:24Z",
        "updated_at": "2026-02-25T19:24:25Z",
        "headline": "ImageMagick has a heap Buffer Over-read  in its DJVU image format handler",
        "content": {
          "excerpt_text": "A heap Buffer Over-read vulnerability exists in the DJVU image format handler. The vulnerability occurs due to integer truncation when calculating the stride (row size) for pixel buffer allocation. The stride calculation overflows a 32-bit signed integer, resulting in an out-of-bounds memory reads.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-r99p-5442-q2x2"
          ],
          "content_hash": "sha256:c12966228d226358dde8c1bb1c9d38454b47045e6cb808faa72057c8df8b16a4"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 4.0,
            "cwes": [
              "CWE-126"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-r99p-5442-q2x2"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27798",
        "url": "https://github.com/advisories/GHSA-qpgx-jfcq-r59f",
        "published_at": "2026-02-25T19:24:05Z",
        "updated_at": "2026-02-25T19:24:06Z",
        "headline": "ImageMagick: Heap Buffer Over-read in WaveletDenoise when processing small images",
        "content": {
          "excerpt_text": "A heap buffer over-read vulnerability occurs when processing an image with small dimension using the `-wavelet-denoise` operator. ``` ==3693336==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x511000001280 at pc 0x5602c8b0cc75 bp 0x7ffcb105d510 sp 0x7ffcb105d500 READ of size 4 at 0x511000001280 thread T0 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-qpgx-jfcq-r59f"
          ],
          "content_hash": "sha256:fede188a260687b77d014972e1a7779e70281c28bb032ea86206fccd444141a2"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 4.0,
            "cwes": [
              "CWE-125",
              "CWE-126"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-qpgx-jfcq-r59f"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-x43w-ph7m-pfjx",
        "url": "https://github.com/advisories/GHSA-x43w-ph7m-pfjx",
        "published_at": "2026-02-25T19:23:47Z",
        "updated_at": "2026-02-25T19:23:48Z",
        "headline": "hexchat crate has a Use After Free vulnerability",
        "content": {
          "excerpt_text": "All versions of this crate have function `deregister_command` which can result in use after free. This is unsound. In addition, all versions since 0.3.0 have \"safe\" macros, which are documented as unsafe to use in threads. In addition, the `hexchat` crate is no longer actively maintained. If users rely on this crate, consider switching to an alternative.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-x43w-ph7m-pfjx"
          ],
          "content_hash": "sha256:62d7991d7e808d5eeb4ada323e686d2fa62308d1f7d2fddfc7e42cfa4a8c7ccd"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-416"
            ],
            "packages": [
              "rust:hexchat"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-x43w-ph7m-pfjx"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-1229",
        "url": "https://github.com/advisories/GHSA-q9hv-hpm4-hj6x",
        "published_at": "2026-02-25T19:17:50Z",
        "updated_at": "2026-02-25T19:17:50Z",
        "headline": "CIRCL has an incorrect calculation in secp384r1 CombinedMult",
        "content": {
          "excerpt_text": "The CombinedMult function in the CIRCL ecc/p384 package (secp384r1 curve) produces an incorrect value for specific inputs. The issue is fixed by using complete addition formulas. ECDH and ECDSA signing relying on this curve are not affected. The bug was fixed in **[v1.6.3](https://github.com/cloudflare/circl/releases/tag/v1.6.3)**.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-q9hv-hpm4-hj6x"
          ],
          "content_hash": "sha256:28f931f7ea0de3143a0fe1bc3f88d725f995ae083d149a445538522a492657b1"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-682"
            ],
            "packages": [
              "go:github.com/cloudflare/circl"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-q9hv-hpm4-hj6x"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-gq5v-qf8q-fp77",
        "url": "https://github.com/advisories/GHSA-gq5v-qf8q-fp77",
        "published_at": "2026-02-25T19:15:56Z",
        "updated_at": "2026-02-25T19:15:57Z",
        "headline": "ImageMagick: Heap-based Buffer Overflow in GetPixelIndex due to metadata-cache desynchronization",
        "content": {
          "excerpt_text": "`OpenPixelCache` updates image channel metadata **before** attempting pixel cache memory allocation. When both memory and disk allocation fail a heap-buffer-overflow read in occurs in any writer that calls `GetPixelIndex`.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-gq5v-qf8q-fp77"
          ],
          "content_hash": "sha256:7c6982e787f3651ce2d42b9469605234d2e14096fa34c20acd7997c80ad03e62"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cvss": 3.3,
            "cwes": [
              "CWE-122",
              "CWE-125"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-gq5v-qf8q-fp77"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-wfx3-6g53-9fgc",
        "url": "https://github.com/advisories/GHSA-wfx3-6g53-9fgc",
        "published_at": "2026-02-25T19:13:32Z",
        "updated_at": "2026-02-25T19:13:34Z",
        "headline": "ImageMagick: Memory Leak in multiple coders that write raw pixel data",
        "content": {
          "excerpt_text": "A memory leak vulnerability exists in multiple coders that write raw pixel data where an object is not freed. ``` Direct leak of 160 byte(s) in 1 object(s) allocated from: ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-wfx3-6g53-9fgc"
          ],
          "content_hash": "sha256:6435e58dcf1242a98aaae9a44889b99d3cc9aadc6ee4e55572fb5fb58ddb84a5"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cvss": 3.7,
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-wfx3-6g53-9fgc"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-3q5f-gmjc-38r8",
        "url": "https://github.com/advisories/GHSA-3q5f-gmjc-38r8",
        "published_at": "2026-02-25T19:13:08Z",
        "updated_at": "2026-02-25T19:13:09Z",
        "headline": "ImageMagick: Memory leak in coders/txt.c without freetype",
        "content": {
          "excerpt_text": "If a `texture` attribute is specified for a TXT file, an attempt will be made to read it via `texture=ReadImage(read_info,exception);`. Later, when retrieving metrics via the `GetTypeMetrics` function, if this function fails (i.e., `status == MagickFalse`), the calling function will exit immediately but fail to release the texture object, leading to memory leakage.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-3q5f-gmjc-38r8"
          ],
          "content_hash": "sha256:7ad2631b2136ca3ddc42cb64d3f245a912fc58a8a20c9f9d76cec06be39f7343"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-3q5f-gmjc-38r8"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-xpg8-7m6m-jf56",
        "url": "https://github.com/advisories/GHSA-xpg8-7m6m-jf56",
        "published_at": "2026-02-25T19:12:48Z",
        "updated_at": "2026-02-25T19:12:49Z",
        "headline": "ImageMagick: SVG-to-MVG Command Injection via coders/svg.c",
        "content": {
          "excerpt_text": "An attacker can inject arbitrary MVG (Magick Vector Graphics) drawing commands in an SVG file that is read by the internal SVG decoder of ImageMagick. The injected MVG commands execute during rendering.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-xpg8-7m6m-jf56"
          ],
          "content_hash": "sha256:7f0c9055a73873a4dc6c3e72260a9b3c8222956b23553cf850b4cb5a20654390"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-77",
              "CWE-116"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xpg8-7m6m-jf56"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-wgxp-q8xq-wpp9",
        "url": "https://github.com/advisories/GHSA-wgxp-q8xq-wpp9",
        "published_at": "2026-02-25T19:12:23Z",
        "updated_at": "2026-02-25T19:12:24Z",
        "headline": "ImageMagick: Malicious PCD files trigger 1‑byte heap Out-of-bounds Read and DoS",
        "content": {
          "excerpt_text": "The PCD coder’s DecodeImage loop allows a crafted PCD file to trigger a 1‑byte heap out-of-bounds read when decoding an image (Denial of service) and potential disclosure of adjacent heap byte.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-wgxp-q8xq-wpp9"
          ],
          "content_hash": "sha256:4412c89e8b1768c67aee59a995ab304357ed87aa442cf82c1225299237c6504d"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cvss": 3.7,
            "cwes": [
              "CWE-125"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-wgxp-q8xq-wpp9"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-3j4x-rwrx-xxj9",
        "url": "https://github.com/advisories/GHSA-3j4x-rwrx-xxj9",
        "published_at": "2026-02-25T19:12:06Z",
        "updated_at": "2026-02-25T19:12:08Z",
        "headline": "mageMagick has a possible use-after-free write in its PDB decoder",
        "content": {
          "excerpt_text": "A use-after-free vulnerability exists in the PDB decoder that will use a stale pointer when a memory allocation fails and that could result in a crash or a single zero byte write. ``` ==4033155==ERROR: AddressSanitizer: UNKNOWN SIGNAL on unknown address 0x000000000000 (pc 0x5589c1971b24 bp 0x7ffdcc7ae2d0 sp 0x7ffdcc7adb20 T0) ``` ``` ==4034812==ERROR: AddressSanitizer: heap-use-after-free on address 0x7f099e9f7800 at pc 0x5605d909ab20 bp 0x7ffe52045b50 sp 0x7ffe52045b40 WRITE of size 1 at...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-3j4x-rwrx-xxj9"
          ],
          "content_hash": "sha256:adfd7ec2f2ccb99d750ac1d393f58137c34bfacff925e9d4b3c6a523ee81f958"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cvss": 3.7,
            "cwes": [
              "CWE-416"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-3j4x-rwrx-xxj9"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-2gq3-ww97-wfjm",
        "url": "https://github.com/advisories/GHSA-2gq3-ww97-wfjm",
        "published_at": "2026-02-25T19:11:50Z",
        "updated_at": "2026-02-25T19:11:50Z",
        "headline": "ImageMagick has a possible heap Use After Free vulnerability in its meta coder",
        "content": {
          "excerpt_text": "A heap Use After Free vulnerability exists in the meta coder when an allocation fails and a single byte is written to a stale pointer. ``` ==535852==ERROR: AddressSanitizer: heap-use-after-free on address 0x5210000088ff at pc 0x5581bacac14d bp 0x7ffdf667edf0 sp 0x7ffdf667ede0 WRITE of size 1 at 0x5210000088ff thread T0 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-2gq3-ww97-wfjm"
          ],
          "content_hash": "sha256:54bd77c72a5da61cba11827f0fdba3cedd7ab8bbce080d4f46290fc84359600f"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cvss": 3.7,
            "cwes": [
              "CWE-416"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-2gq3-ww97-wfjm"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-6j87-m5qx-9fqp",
        "url": "https://github.com/advisories/GHSA-6j87-m5qx-9fqp",
        "published_at": "2026-02-25T19:11:31Z",
        "updated_at": "2026-02-25T19:11:33Z",
        "headline": "Craft CMS has Stored XSS in Table Field in its \"Row Heading\" Column Type",
        "content": {
          "excerpt_text": "A stored Cross-site Scripting (XSS) vulnerability exists in the `editableTable.twig` component when using the `Row Heading` column type. The application fails to sanitize input within row headings, allowing an attacker to execute arbitrary JavaScript when another user views a page with the malicious table field. ## Prerequisites * An administrator account * `allowAdminChanges` must be enabled in production, which is [against security...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-6j87-m5qx-9fqp"
          ],
          "content_hash": "sha256:7b8468a1999d4ee8d24cfe2768bc937e818933ab0d007cf65a4849bbce427de1"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-79"
            ],
            "packages": [
              "composer:craftcms/cms",
              "composer:craftcms/cms"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-6j87-m5qx-9fqp"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27696",
        "url": "https://github.com/advisories/GHSA-3c45-4pj5-ch7m",
        "published_at": "2026-02-25T19:08:18Z",
        "updated_at": "2026-02-25T19:08:18Z",
        "headline": "changedetection.io is Vulnerable to SSRF via Watch URLs",
        "content": {
          "excerpt_text": "## Summary Changedetection.io is vulnerable to Server-Side Request Forgery (SSRF) because the URL validation function `is_safe_valid_url()` does not validate the resolved IP address of watch URLs against private, loopback, or link-local address ranges. An authenticated user (or any user when no password is configured, which is the default) can add a watch for internal network URLs such as: - `http://169.254.169.254` - `http://10.0.0.1/` - `http://127.0.0.1/` The application fetches these...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-3c45-4pj5-ch7m"
          ],
          "content_hash": "sha256:28a4dcd879035b5be1dd2250688da14dbaf888160d947b7da8030a33e1fe368f"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.6,
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "pip:changedetection.io"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-3c45-4pj5-ch7m"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27645",
        "url": "https://github.com/advisories/GHSA-mw8m-398g-h89w",
        "published_at": "2026-02-25T19:07:44Z",
        "updated_at": "2026-02-25T19:07:45Z",
        "headline": "changedetection.io Vulnerable to Reflected XSS in RSS Single Watch Error Response",
        "content": {
          "excerpt_text": "### Summary Three security vulnerabilities were identified in [changedetection.io](http://changedetection.io/) through source code review and live validation against a locally deployed Docker instance. All vulnerabilities were confirmed exploitable on the latest version (0.53.6) it was additionally validated at scale against 500 internet-facing instances discovered via FOFA search engine, producing 5K+ confirmed detections using a custom Nuclei template, demonstrating widespread real-world...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-mw8m-398g-h89w"
          ],
          "content_hash": "sha256:24949c43ce46f69cb1d054cb8dfa9015c7bdbb590d18e4285323472a04f35bb3"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79"
            ],
            "packages": [
              "pip:changedetection.io"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-mw8m-398g-h89w"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27641",
        "url": "https://github.com/advisories/GHSA-65mp-fq8v-56jr",
        "published_at": "2026-02-25T19:06:50Z",
        "updated_at": "2026-02-25T19:06:51Z",
        "headline": "Flask-Reuploaded vulnerable to Remote Code Execution via Server-Side Template Injection",
        "content": {
          "excerpt_text": "### Impact A critical path traversal and extension bypass vulnerability in Flask-Reuploaded allows remote attackers to achieve arbitrary file write and remote code execution through Server-Side Template Injection (SSTI). ### Patches Flask-Reuploaded has been patched in version 1.5.0 ### Workarounds 1. **Do not pass user input to the `name` parameter** 2. Use auto-generated filenames only 3. Implement strict input validation if `name` must be used ```python from werkzeug.utils import...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-65mp-fq8v-56jr"
          ],
          "content_hash": "sha256:0f1c981b164f3fe5d5349892a4c7c23c3a920f180e550635b4fa2fd2c5a2c45b"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 9.8,
            "cwes": [
              "CWE-1336"
            ],
            "packages": [
              "pip:flask-reuploaded"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-65mp-fq8v-56jr"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27610",
        "url": "https://github.com/advisories/GHSA-jhp4-jvq3-w5xr",
        "published_at": "2026-02-25T19:00:07Z",
        "updated_at": "2026-02-25T19:00:08Z",
        "headline": "Parse Dashboard Has a Cache Key Collision that Leaks Master Key to Read-Only Sessions",
        "content": {
          "excerpt_text": "### Impact The `ConfigKeyCache` uses the same cache key for both master key and read-only master key when resolving function-typed keys. Under specific timing conditions, a read-only user can receive the cached full master key, or a regular user can receive the cached read-only master key. ### Patches The fix uses distinct cache keys for master key and read-only master key. ### Workarounds Avoid using function-typed master keys, or remove the `agent` configuration block from your dashboard...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-jhp4-jvq3-w5xr"
          ],
          "content_hash": "sha256:b8185ad54520f4344cecb67ed209d5f16be80247b99e83c7dff5555b1ea0104b"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-1289"
            ],
            "packages": [
              "npm:parse-dashboard"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-jhp4-jvq3-w5xr"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27609",
        "url": "https://github.com/advisories/GHSA-3534-xp88-25rc",
        "published_at": "2026-02-25T18:59:58Z",
        "updated_at": "2026-02-25T18:59:59Z",
        "headline": "Parse Dashboard is Missing CSRF Protection for its Agent Endpoint",
        "content": {
          "excerpt_text": "### Impact The AI Agent API endpoint (`POST /apps/:appId/agent`) lacks CSRF protection. An attacker can craft a malicious page that, when visited by an authenticated dashboard user, submits requests to the agent endpoint using the victim's session. ### Patches The fix adds CSRF middleware to the agent endpoint and embeds a CSRF token in the dashboard page. ### Workarounds Remove the `agent` configuration block from your dashboard configuration. Dashboards without an `agent` config are not...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-3534-xp88-25rc"
          ],
          "content_hash": "sha256:3fafbf13aa02a926ca2f601c13af990b390c277ba8afaa4d325e88b279425dd0"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-352"
            ],
            "packages": [
              "npm:parse-dashboard"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-3534-xp88-25rc"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27608",
        "url": "https://github.com/advisories/GHSA-cvwj-6c9h-jg6v",
        "published_at": "2026-02-25T18:59:44Z",
        "updated_at": "2026-02-25T18:59:45Z",
        "headline": "Parse Dashboard is Missing Authorization for its Agent Endpoint",
        "content": {
          "excerpt_text": "### Impact The AI Agent API endpoint (`POST /apps/:appId/agent`) does not enforce authorization. Authenticated users scoped to specific apps can access any other app's agent endpoint by changing the app ID in the URL. Read-only users are given the full master key instead of the read-only master key and can supply write permissions in the request body to perform write and delete operations. Affected are only dashboards with `agent` configuration enabled. ### Patches The fix adds per-app...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-cvwj-6c9h-jg6v"
          ],
          "content_hash": "sha256:c347b0ddc882ad758c1b8ef25b3ab81d0b70f3d620726e0213cdecfbc5f0963f"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cwes": [
              "CWE-862"
            ],
            "packages": [
              "npm:parse-dashboard"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-cvwj-6c9h-jg6v"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25733",
        "url": "https://github.com/advisories/GHSA-rwj9-7j48-9f7q",
        "published_at": "2026-02-25T18:58:20Z",
        "updated_at": "2026-02-25T18:58:22Z",
        "headline": "Rucio WebUI Vulnerable to Stored Cross-site Scripting (XSS) through Custom Rule Function",
        "content": {
          "excerpt_text": "### Summary A stored Cross-site Scripting (XSS) vulnerability was identified in the Custom Rules function of the WebUI where attacker-controlled input is persisted by the backend and later rendered in the WebUI without proper output encoding. This allows arbitrary JavaScript execution in the context of the WebUI for users who view affected pages, potentially enabling session token theft or unauthorized actions. --- ### Details A malicious payload supplied in the `comment` field is stored by...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-rwj9-7j48-9f7q"
          ],
          "content_hash": "sha256:d6d58b2721aa8754780ed573534b690618125d8d832c957041f099f3973c7b42"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.3,
            "cwes": [
              "CWE-79",
              "CWE-1004"
            ],
            "packages": [
              "pip:rucio-webui",
              "pip:rucio-webui",
              "pip:rucio-webui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-rwj9-7j48-9f7q"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27702",
        "url": "https://github.com/advisories/GHSA-rvhr-26g4-p2r8",
        "published_at": "2026-02-25T18:57:39Z",
        "updated_at": "2026-02-25T18:57:40Z",
        "headline": "Budibase: Remote Code Execution via Unsafe eval() in View Filter Map Function (Budibase Cloud)",
        "content": {
          "excerpt_text": "## Summary A critical unsafe `eval()` vulnerability in Budibase's view filtering implementation allows any authenticated user (including free tier accounts) to execute arbitrary JavaScript code on the server. **This vulnerability ONLY affects Budibase Cloud (SaaS)** - self-hosted deployments use native CouchDB views and are not vulnerable. The vulnerability exists in `packages/server/src/db/inMemoryView.ts` where user-controlled view map functions are directly evaluated without sanitization....",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-rvhr-26g4-p2r8"
          ],
          "content_hash": "sha256:2c8ec236f63e3a98a56bf6b87d52e4580b8a7c18a4a889321bf12f22435dc63e"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 9.9,
            "cwes": [
              "CWE-20",
              "CWE-94",
              "CWE-95"
            ],
            "packages": [
              "npm:budibase"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-rvhr-26g4-p2r8"
            }
          },
          "deprecation": {
            "type": "removal",
            "confidence": "low",
            "source": "keyword_scan",
            "provenance": {
              "method": "keyword_scan",
              "authority": "GitHub Security Advisories",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-rvhr-26g4-p2r8"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27732",
        "url": "https://github.com/advisories/GHSA-h39h-7cvg-q7j6",
        "published_at": "2026-02-25T18:57:05Z",
        "updated_at": "2026-02-25T18:57:07Z",
        "headline": "AVideo has Authenticated Server-Side Request Forgery via downloadURL in aVideoEncoder.json.php",
        "content": {
          "excerpt_text": "### Vulnerability Type Authenticated Server-Side Request Forgery (SSRF) ### Affected Product/Versions AVideo versions prior to 22 (tested on AVideo 21.x). ### Root Cause Summary The `aVideoEncoder.json.php` API endpoint accepts a `downloadURL` parameter and fetches the referenced resource server-side without proper validation or an allow-list. This allows authenticated users to trigger server-side requests to arbitrary URLs (including internal network endpoints). ### Impact Summary An...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-h39h-7cvg-q7j6"
          ],
          "content_hash": "sha256:71048cc519ec14a42c3bbd5c529d11051cf375ae844f9e2daaf56a397ccbe7fe"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.1,
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "composer:wwbn/avideo"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-h39h-7cvg-q7j6"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25138",
        "url": "https://github.com/advisories/GHSA-38wq-6q2w-hcf9",
        "published_at": "2026-02-25T18:53:42Z",
        "updated_at": "2026-02-25T18:53:43Z",
        "headline": "Rucio WebUI has Username Enumeration via Login Error Message",
        "content": {
          "excerpt_text": "### Summary The WebUI login endpoint returns distinct error messages depending on whether a supplied username exists, allowing unauthenticated attackers to enumerate valid usernames. ### Details When submitting invalid credentials to `/ui/login`, the WebUI responds with different error messages based on the existence of the provided username (identity). A non-existent username results in an error indicating that no account is associated with the identity, while an existing username with an...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-38wq-6q2w-hcf9"
          ],
          "content_hash": "sha256:8ec36c5359f7380e5291ac0d898c580819e92937b2b3bf8e6ad8e5b454e79833"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-204"
            ],
            "packages": [
              "pip:rucio-webui",
              "pip:rucio-webui",
              "pip:rucio-webui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-38wq-6q2w-hcf9"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25136",
        "url": "https://github.com/advisories/GHSA-h79m-5jjm-jm4q",
        "published_at": "2026-02-25T18:53:29Z",
        "updated_at": "2026-02-25T18:53:32Z",
        "headline": "Rucio WebUI has a Reflected Cross-site Scripting Vulnerability",
        "content": {
          "excerpt_text": "### Summary A reflected Cross-site Scripting vulnerability was located in the rendering of the ExceptionMessage of the WebUI 500 error which could allow attackers to steal login session tokens of users who navigate to a specially crafted URL. #### Details The WebUI error message renders `ExceptionMessage` (which can contain user-controlled input) as unencoded HTML. Server code that produces the message is in `common.py` - specifically `error_headers -> _error_response ->...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-h79m-5jjm-jm4q"
          ],
          "content_hash": "sha256:37f780327cdb4880d3c790e567e0b0af97806fec5437e675de29448872a59e80"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.1,
            "cwes": [
              "CWE-79",
              "CWE-1004"
            ],
            "packages": [
              "pip:rucio-webui",
              "pip:rucio-webui",
              "pip:rucio-webui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-h79m-5jjm-jm4q"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27595",
        "url": "https://github.com/advisories/GHSA-qwc3-h9mg-4582",
        "published_at": "2026-02-25T18:37:53Z",
        "updated_at": "2026-02-25T18:37:55Z",
        "headline": "Parse Dashboard has incomplete authentication on AI Agent endpoint",
        "content": {
          "excerpt_text": "### Impact The AI Agent API endpoint (POST `/apps/:appId/agent`) lacks authentication. Unauthenticated remote attackers can send requests to the endpoint and perform arbitrary database operations against any connected Parse Server using the master key. ### Patches The fix adds authentication middleware to the agent endpoint. ### Workarounds Remove the `agent` configuration block from your dashboard configuration. Dashboards without an `agent` config are not affected. ### Resources - GitHub...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-qwc3-h9mg-4582"
          ],
          "content_hash": "sha256:73abab1a0b54a85a53fc7334f9e4832da561f972f782a652e04dea634e78de80"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cwes": [
              "CWE-306"
            ],
            "packages": [
              "npm:parse-dashboard"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-qwc3-h9mg-4582"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27830",
        "url": "https://github.com/advisories/GHSA-5476-xc4j-rqcv",
        "published_at": "2026-02-25T18:35:23Z",
        "updated_at": "2026-02-25T18:35:25Z",
        "headline": "c3p0 vulnerable to Remote Code Execution via unsafe deserialization of userOverridesAsString property",
        "content": {
          "excerpt_text": "### Impact c3p0 is vulnerable to attack via maliciously crafted Java-serialized objects and `javax.naming.Reference` instances. Several c3p0 `ConnectionPoolDataSource` implementations have a property called `userOverridesAsString` which conceptually represents a `Map >`. Prior to v0.12.0, that property was maintained as a hex-encoded serialized object. Any attacker able to reset this property, on an existing `ConnectionPoolDataSource` or via maliciously crafted serialized objects or...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-5476-xc4j-rqcv"
          ],
          "content_hash": "sha256:aa73173dec706e52d4f8239f8185cfc35ce4a1c930a6371d2e35f3acfdbbefa7"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-94",
              "CWE-502"
            ],
            "packages": [
              "maven:com.mchange:c3p0"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-5476-xc4j-rqcv"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-24005",
        "url": "https://github.com/advisories/GHSA-9fj4-3849-rv9g",
        "published_at": "2026-02-25T18:30:40Z",
        "updated_at": "2026-02-25T18:30:40Z",
        "headline": "OpenKruise PodProbeMarker is Vulnerable to SSRF via Unrestricted Host Field",
        "content": {
          "excerpt_text": "## Summary PodProbeMarker allows defining custom probes with TCPSocket or HTTPGet handlers. The webhook validation does not restrict the Host field in these probe configurations. Since kruise-daemon runs with hostNetwork=true, it executes probes from the node network namespace. An attacker with PodProbeMarker creation permission can specify arbitrary Host values (127.0.0.1, 169.254.169.254, internal IPs) to trigger SSRF from the node, perform port scanning, and receive response feedback...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-9fj4-3849-rv9g"
          ],
          "content_hash": "sha256:6b35557d00fb6ba15c49e980f10fd81a90611bec8161ac0264f08d1e018b5a07"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "go:github.com/openkruise/kruise",
              "go:github.com/openkruise/kruise"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-9fj4-3849-rv9g"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-22866",
        "url": "https://github.com/advisories/GHSA-c6rr-7pmc-73wc",
        "published_at": "2026-02-25T18:26:58Z",
        "updated_at": "2026-02-25T18:26:59Z",
        "headline": "ENS DNSSEC Oracle Vulnerable to RSA Signature Forgery via Missing PKCS#1 v1.5 Padding Validation",
        "content": {
          "excerpt_text": "### Impact The `RSASHA256Algorithm` and `RSASHA1Algorithm` contracts fail to validate PKCS#1 v1.5 padding structure when verifying RSA signatures. The contracts only check if the last 32 (or 20) bytes of the decrypted signature match the expected hash. This enables Bleichenbacher's 2006 signature forgery attack against DNS zones using RSA keys with low public exponents (e=3). Two ENS-supported TLDs (.cc and .name) use e=3 for their Key Signing Keys, allowing any domain under these TLDs to be...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-c6rr-7pmc-73wc"
          ],
          "content_hash": "sha256:aac1c8edf7e83909d75651c8e81b07d26eb8e66b9240f7650a74879821fbcbfc"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-347"
            ],
            "packages": [
              "npm:@ensdomains/ens-contracts"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-c6rr-7pmc-73wc"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27727",
        "url": "https://github.com/advisories/GHSA-m2cm-222f-qw44",
        "published_at": "2026-02-25T18:20:05Z",
        "updated_at": "2026-02-25T18:20:06Z",
        "headline": "mchange-commons-java: Remote Code Execution via JNDI Reference Resolution",
        "content": {
          "excerpt_text": "### Impact mchange-commons-java includes code that mirrors early implementations of JNDI functionality, including support for remote `factoryClassLocation` values, by which code can be downloaded and invoked within a running application. If an attacker can provoke an application to read a maliciously crafted `jaxax.naming.Reference` or serialized object, they can provoke the download and execution of malicious code. Implementations of this functionality within the JDK were disabled by...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-m2cm-222f-qw44"
          ],
          "content_hash": "sha256:b3fdc696550a1e3b389667749ec4b3e805586ea491469f0de476c9fb2bd2857b"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-502"
            ],
            "packages": [
              "maven:com.mchange:mchange-commons-java"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-m2cm-222f-qw44"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27829",
        "url": "https://github.com/advisories/GHSA-cj9f-h6r6-4cx2",
        "published_at": "2026-02-25T18:11:47Z",
        "updated_at": "2026-02-25T18:11:48Z",
        "headline": "Astro is vulnerable to SSRF due to missing allowlist enforcement in remote image inferSize",
        "content": {
          "excerpt_text": "## Summary A bug in Astro's image pipeline allows bypassing `image.domains` / `image.remotePatterns` restrictions, enabling the server to fetch content from unauthorized remote hosts. ## Details Astro provides an `inferSize` option that fetches remote images at render time to determine their dimensions. Remote image fetches are intended to be restricted to domains the site developer has manually authorized (using the `image.domains` or `image.remotePatterns` options). However, when...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-cj9f-h6r6-4cx2"
          ],
          "content_hash": "sha256:e0ce577b4d97f33587c28392353acc8cfa2b15eee0e749bf9815fb07ca2bc26e"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.5,
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "npm:@astrojs/node"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-cj9f-h6r6-4cx2"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27728",
        "url": "https://github.com/advisories/GHSA-jmhp-5558-qxh5",
        "published_at": "2026-02-25T18:09:47Z",
        "updated_at": "2026-02-25T18:09:49Z",
        "headline": "OneUptime: OS Command Injection in Probe NetworkPathMonitor via unsanitized destination in traceroute exec()",
        "content": {
          "excerpt_text": "## Summary An OS command injection vulnerability in `NetworkPathMonitor.performTraceroute()` allows any authenticated project user to execute arbitrary operating system commands on the Probe server by injecting shell metacharacters into a monitor's destination field. ## Details The vulnerability exists in [`Probe/Utils/Monitors/MonitorTypes/NetworkPathMonitor.ts`](Probe/Utils/Monitors/MonitorTypes/NetworkPathMonitor.ts), lines 149–191. The `performTraceroute()` method constructs a shell...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-jmhp-5558-qxh5"
          ],
          "content_hash": "sha256:f72bbb7d7d51b3afd51f364b5b6e21298c4fb3fa3a6ae2f5d115d09e9767f93d"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 10.0,
            "cwes": [
              "CWE-78"
            ],
            "packages": [
              "npm:@oneuptime/common"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-jmhp-5558-qxh5"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27700",
        "url": "https://github.com/advisories/GHSA-xh87-mx6m-69f3",
        "published_at": "2026-02-25T18:02:19Z",
        "updated_at": "2026-02-25T18:02:22Z",
        "headline": "Hono is Vulnerable to Authentication Bypass by IP Spoofing in AWS Lambda ALB conninfo",
        "content": {
          "excerpt_text": "## Summary When using the AWS Lambda adapter (`hono/aws-lambda`) behind an Application Load Balancer (ALB), the `getConnInfo()` function incorrectly selected the first value from the `X-Forwarded-For` header. Because AWS ALB appends the real client IP address to the end of the `X-Forwarded-For` header, the first value can be attacker-controlled. This could allow IP-based access control mechanisms (such as the `ipRestriction` middleware) to be bypassed. ## Details In ALB environments, AWS...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-xh87-mx6m-69f3"
          ],
          "content_hash": "sha256:436ec9a5a51a3178fbc9f58232c417f77ea53345a97ccc148585b8a1199baa17"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.2,
            "cwes": [
              "CWE-290",
              "CWE-345"
            ],
            "packages": [
              "npm:hono"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xh87-mx6m-69f3"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-2phg-qgmm-r638",
        "url": "https://github.com/advisories/GHSA-2phg-qgmm-r638",
        "published_at": "2026-02-25T17:36:44Z",
        "updated_at": "2026-02-25T17:36:45Z",
        "headline": "Sliver has Potential Zip Bomb Denial of Service in GzipEncoder",
        "content": {
          "excerpt_text": "### Summary GzipEncoder does not limit output size when processing compressed data. This allows unauthenticated remote attackers to crash sliver server by sending a http request with highly compressed gzip data (aka zip bomb). ### Details In `util/encoders/gzip.go`, `Decode()` method decompresses given data by reading the entire gzip buffer at once without limiting output size. ### PoC ```python data = gzip.compress(bytes(1024 * 1024 * 1024)) * 16 requests.post(f\"http://172.17.0.2/{nonce}\",...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-2phg-qgmm-r638"
          ],
          "content_hash": "sha256:6aabdae9894f6196c9c1dc0ec943e7bf96c31855a7198a000b84f6ce4131d069"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-409"
            ],
            "packages": [
              "go:github.com/BishopFox/sliver"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-2phg-qgmm-r638"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27597",
        "url": "https://github.com/advisories/GHSA-f229-3862-4942",
        "published_at": "2026-02-25T17:26:23Z",
        "updated_at": "2026-02-25T17:26:24Z",
        "headline": "@enclave-vm/core is vulnerable to Sandbox Escape",
        "content": {
          "excerpt_text": "## Summary It is possible to escape the security boundraries set by `@enclave-vm/core`, which can be used to achieve remote code execution (RCE). The issue has been fixed in version **2.11.1**. --- ## Details It is possible to obtain the native `Object` constructor (instead of the `SafeObject` wrapper). This can be used to get retrieve property descriptors via `Object.getOwnPropertyDescriptors`, allowing access to properties otherwise restricted by the sandbox. When a memory limit is set...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-f229-3862-4942"
          ],
          "content_hash": "sha256:30e0d3cd2b350fb998aa66bd2b13f20244ae39914b073a08197b39a2cacffb10"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 10.0,
            "cwes": [
              "CWE-94"
            ],
            "packages": [
              "npm:@enclave-vm/core"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-f229-3862-4942"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27626",
        "url": "https://github.com/advisories/GHSA-49gm-hh7w-wfvf",
        "published_at": "2026-02-25T16:18:22Z",
        "updated_at": "2026-02-25T16:18:24Z",
        "headline": "OliveTin: OS Command Injection via `password` argument type and webhook JSON extraction bypasses shell safety checks",
        "content": {
          "excerpt_text": "### Summary OliveTin's shell mode safety check (`checkShellArgumentSafety`) blocks several dangerous argument types but not `password`. A user supplying a `password`-typed argument can inject shell metacharacters that execute arbitrary OS commands. A second independent vector allows unauthenticated RCE via webhook-extracted JSON values that skip type safety checks entirely before reaching `sh -c`. ### Details **Vector 1 — `password` type bypasses shell safety check (PR:L)**...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-49gm-hh7w-wfvf"
          ],
          "content_hash": "sha256:762abe6c32faef50a3d9f513784c852744dd6fb78b7fd3633997e5f46485c554"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 10.0,
            "cwes": [
              "CWE-78"
            ],
            "packages": [
              "go:github.com/OliveTin/OliveTin"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-49gm-hh7w-wfvf"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27628",
        "url": "https://github.com/advisories/GHSA-2rw7-x74f-jg35",
        "published_at": "2026-02-25T16:09:03Z",
        "updated_at": "2026-02-25T16:09:03Z",
        "headline": "pypdf has a possible infinite loop when loading circular /Prev entries in cross-reference streams",
        "content": {
          "excerpt_text": "### Impact An attacker who uses this vulnerability can craft a PDF which leads to an infinite loop. This requires reading the file. ### Patches This has been fixed in [pypdf==6.7.2](https://github.com/py-pdf/pypdf/releases/tag/6.7.2). ### Workarounds If users cannot upgrade yet, consider applying the changes from PR [#3655](https://github.com/py-pdf/pypdf/pull/3655).",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-2rw7-x74f-jg35"
          ],
          "content_hash": "sha256:bb8e194622b1ee12bdd40233be67e15072a4a1710e547e026cca074c29071efb"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cwes": [
              "CWE-835"
            ],
            "packages": [
              "pip:pypdf"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-2rw7-x74f-jg35"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27621",
        "url": "https://github.com/advisories/GHSA-xfvg-8v67-j7wp",
        "published_at": "2026-02-25T16:06:59Z",
        "updated_at": "2026-02-25T16:07:00Z",
        "headline": "TypiCMS Core has Stored Cross-Site Scripting (XSS) via SVG File Upload",
        "content": {
          "excerpt_text": "#### I. Summary A Stored Cross-Site Scripting (XSS) vulnerability exists in the file upload module of TypiCMS. The application allows users with file upload permissions to upload SVG files. While there is a MIME type validation, the content of the SVG file is not sanitized. An attacker can upload a specially crafted SVG file containing malicious JavaScript code. When another user (such as an administrator) views or accesses this file through the application, the script executes in their...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-xfvg-8v67-j7wp"
          ],
          "content_hash": "sha256:41519403da4788895afadf9f56c7a4f1071338ada9eaa25511a22e1f36e3cd73"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-79"
            ],
            "packages": [
              "composer:typicms/core"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xfvg-8v67-j7wp"
            }
          },
          "deprecation": {
            "type": "removal",
            "affects": [
              "potentially",
              "svg"
            ],
            "confidence": "low",
            "source": "keyword_scan",
            "provenance": {
              "method": "keyword_scan",
              "authority": "GitHub Security Advisories",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xfvg-8v67-j7wp"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27614",
        "url": "https://github.com/advisories/GHSA-vp6q-7m36-pq3w",
        "published_at": "2026-02-25T16:06:00Z",
        "updated_at": "2026-02-25T16:06:02Z",
        "headline": "Bugsink is vulnerable to Stored XSS via Pygments fallback in stacktrace rendering",
        "content": {
          "excerpt_text": "### Summary An unauthenticated attacker who can submit events to a Bugsink project can store arbitrary JavaScript in an event. The payload executes only if a user explicitly views the affected Stacktrace in the web UI. ### Details When Pygments returns more lines than it was given (a known upstream quirk that triggers with Ruby heredoc-style input), `_pygmentize_lines()` in `theme/templatetags/issues.py:75-77` falls back to returning the raw input lines. `mark_safe()` at line 111-113 is then...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-vp6q-7m36-pq3w"
          ],
          "content_hash": "sha256:dbb3de70a52ad2c8e5ea139690ff5dd5c801857f4b8f11382e51ef46da673932"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 9.3,
            "cwes": [
              "CWE-79"
            ],
            "packages": [
              "pip:bugsink"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-vp6q-7m36-pq3w"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27612",
        "url": "https://github.com/advisories/GHSA-fm8c-6m29-rp6j",
        "published_at": "2026-02-25T16:04:41Z",
        "updated_at": "2026-02-25T16:04:42Z",
        "headline": "repostat: Reflected Cross-Site Scripting (XSS) via repo prop in RepoCard",
        "content": {
          "excerpt_text": "### Impact The `RepoCard` component is vulnerable to Reflected Cross-Site Scripting (XSS). The vulnerability occurs because the component uses React's `dangerouslySetInnerHTML` to render the repository name (`repo` prop) during the loading state without any sanitization. If a developer using this package passes unvalidated user input directly into the `repo` prop (for example, reading it from a URL query parameter), an attacker can execute arbitrary JavaScript in the context of the user's...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-fm8c-6m29-rp6j"
          ],
          "content_hash": "sha256:c3f2eb5c2238c86938b288ce7f5ab3aac93a146019b46173c983f8ecfe36dc38"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79"
            ],
            "packages": [
              "npm:repostat"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-fm8c-6m29-rp6j"
            }
          },
          "deprecation": {
            "type": "removal",
            "confidence": "low",
            "source": "keyword_scan",
            "provenance": {
              "method": "keyword_scan",
              "authority": "GitHub Security Advisories",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-fm8c-6m29-rp6j"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27611",
        "url": "https://github.com/advisories/GHSA-8vrh-3pm2-v4v6",
        "published_at": "2026-02-25T16:00:49Z",
        "updated_at": "2026-02-25T16:00:51Z",
        "headline": "FileBrowser Quantum: Password Protection Not Enforced on Shared File Links",
        "content": {
          "excerpt_text": "### Summary When users share password-protected files, the recipient can completely bypass the password and still download the file. ### Details This happens because the API returns a direct download link in the details of the share, which is accessible to anyone with JUST THE SHARE LINK, even without the password. ### PoC 1. As an authenticated user, create a share for a file, with a password specified in \"Optional password\" (make sure to allow anonymous access as the PoC doesn't explain...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-8vrh-3pm2-v4v6"
          ],
          "content_hash": "sha256:fc815ee38f3e6ceaab28bd004b2cd2082153b87aefb57c3dafd7f46940a6b37c"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-200",
              "CWE-288"
            ],
            "packages": [
              "go:github.com/gtsteffaniak/filebrowser/backend"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-8vrh-3pm2-v4v6"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-mhc9-48gj-9gp3",
        "url": "https://github.com/advisories/GHSA-mhc9-48gj-9gp3",
        "published_at": "2026-02-25T15:24:18Z",
        "updated_at": "2026-02-25T15:24:20Z",
        "headline": "Fickling has safety check bypass via REDUCE+BUILD opcode sequence",
        "content": {
          "excerpt_text": "# Assessment It is believed that the analysis pass works as intended, `REDUCE` and `BUILD` are not at fault here. The few potentially unsafe modules have been added to the blocklist (https://github.com/trailofbits/fickling/commit/0c4558d950daf70e134090573450ddcedaf10400). # Original report ### Summary All 5 of fickling's safety interfaces — `is_likely_safe()`, `check_safety()`, CLI `--check-safety`, `always_check_safety()`, and the `check_safety()` context manager — report `LIKELY_SAFE`...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-mhc9-48gj-9gp3"
          ],
          "content_hash": "sha256:001250fd3791f010946455a0b1b05a9a8f36df021279bd01f929b0b3eb5240e7"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-184"
            ],
            "packages": [
              "pip:fickling"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-mhc9-48gj-9gp3"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25984",
        "url": "https://github.com/advisories/GHSA-273h-m46v-96q4",
        "published_at": "2026-02-25T15:20:15Z",
        "updated_at": "2026-02-25T15:20:19Z",
        "headline": "ImageMagick: Integer Overflow in PSB (PSD v2) RLE decoding path causes heap Out of Bounds reads for 32-bit builds",
        "content": {
          "excerpt_text": "An integer overflow in the PSB (PSD v2) RLE decoding path causes a heap out-of-bounds read on 32-bit builds. This can lead to information disclosure or a crash when processing crafted PSB files. ``` ================================================================= ==3298==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf512eb00 at pc 0xf76760b5 bp 0xffc1dfb8 sp 0xffc1dfa8 READ of size 8 at 0xf512eb00 thread T0 #0 0xf76760b4 in ReadPSDChannelRLE coders/psd.c:1141 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-273h-m46v-96q4"
          ],
          "content_hash": "sha256:0afcb87b7f901ffb7eb9c8c2777750ddf98fbb0262940203177f2e69b0248961"
        },
        "signals": {
          "severity": {
            "level": "low",
            "source": "github_advisory",
            "cvss": 3.7,
            "cwes": [
              "CWE-125",
              "CWE-190"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-273h-m46v-96q4"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2025-50180",
        "url": "https://github.com/advisories/GHSA-3c9r-837r-qqm4",
        "published_at": "2026-02-25T15:19:41Z",
        "updated_at": "2026-02-25T15:19:44Z",
        "headline": "esm.sh is vulnerable to full-response SSRF",
        "content": {
          "excerpt_text": "### Summary esh.sh is vulnerable to a full-response SSRF, allowing an attacker to retrieve information from internal websites through the vulnerability. ### Details Vulnerable code location: https://github.com/esm-dev/esm.sh/blob/f80ff8c8d58749e77fa964abde468fc61f8bd89e/server/router.go#L511 If the internal address has a suffix listed below, the attacker can obtain content from the specified internal address. eg: https://esm.sh/https://local.site/test.md ``` \".js\", \".ts\", \".mjs\", \".mts\",...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-3c9r-837r-qqm4"
          ],
          "content_hash": "sha256:e0bbe431c388d900bd31077b1007fc2083e25693f3b71a2e3758383a93309d0d"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "go:github.com/esm-dev/esm.sh"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-3c9r-837r-qqm4"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27598",
        "url": "https://github.com/advisories/GHSA-6v48-fcq6-ff23",
        "published_at": "2026-02-24T21:43:15Z",
        "updated_at": "2026-02-24T21:43:16Z",
        "headline": "Dagu: Path traversal in DAG creation allows arbitrary YAML file write outside DAGs directory",
        "content": {
          "excerpt_text": "The `CreateNewDAG` API endpoint (`POST /api/v1/dags`) does not validate the DAG name before passing it to the file store. While `RenameDAG` calls `core.ValidateDAGName()` to reject names containing path separators (line 273 in `dags.go`), `CreateNewDAG` skips this validation entirely and passes user input directly to `dagStore.Create()`. In `internal/persis/filedag/store.go`, the `generateFilePath` function (line 493) checks if the name contains a path separator, and if so, resolves it via...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-6v48-fcq6-ff23"
          ],
          "content_hash": "sha256:616da122849a1a419b3c730e1a45b7a3547e328b15e0036e1f735efa81608dc6"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-22"
            ],
            "packages": [
              "go:github.com/dagu-org/dagu"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-6v48-fcq6-ff23"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "GHSA-mxhj-88fx-4pcv",
        "url": "https://github.com/advisories/GHSA-mxhj-88fx-4pcv",
        "published_at": "2026-02-24T21:41:31Z",
        "updated_at": "2026-02-24T21:41:34Z",
        "headline": "Fickling: OBJ opcode call invisibility bypasses all safety checks",
        "content": {
          "excerpt_text": "# Assessment The interpreter so it behaves closer to CPython when dealing with `OBJ`, `NEWOBJ`, and `NEWOBJ_EX` opcodes (https://github.com/trailofbits/fickling/commit/ff423dade2bb1f72b2b48586c022fac40cbd9a4a). # Original report ## Summary All 5 of fickling's safety interfaces -- `is_likely_safe()`, `check_safety()`, CLI `--check-safety`, `always_check_safety()`, and the `check_safety()` context manager -- report `LIKELY_SAFE` / raise no exceptions for pickle files that use the OBJ opcode to...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-mxhj-88fx-4pcv"
          ],
          "content_hash": "sha256:78e9b0daaa3d91d4290a0435c530516c4f54372131f179210af8c32166cc05b6"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-436"
            ],
            "packages": [
              "pip:fickling"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-mxhj-88fx-4pcv"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27593",
        "url": "https://github.com/advisories/GHSA-jxq9-79vj-rgvw",
        "published_at": "2026-02-24T21:09:23Z",
        "updated_at": "2026-02-24T21:09:24Z",
        "headline": "Statamic is vulnerable to account takeover via password reset link injection",
        "content": {
          "excerpt_text": "## Impact An attacker may leverage a vulnerability in the password reset feature to capture a user's token and reset the password on their behalf. The attacker must know the email address of a valid account on the site, and the actual user must blindly click the link in their email even though they didn't request the reset. ## Patches This has been fixed in 6.3.3 and 5.73.10.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-jxq9-79vj-rgvw"
          ],
          "content_hash": "sha256:284f3cfffd3e29b3c85eb2f0c62ca43941db6f3545ba60ee2f7a1e42b8ce1415"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 9.3,
            "cwes": [
              "CWE-640"
            ],
            "packages": [
              "composer:statamic/cms",
              "composer:statamic/cms"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-jxq9-79vj-rgvw"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27572",
        "url": "https://github.com/advisories/GHSA-243v-98vx-264h",
        "published_at": "2026-02-24T21:08:06Z",
        "updated_at": "2026-02-24T21:08:07Z",
        "headline": "Wasmtime can panic when adding excessive fields to a `wasi:http/types.fields` instance",
        "content": {
          "excerpt_text": "### Impact Wasmtime's implementation of the `wasi:http/types.fields` resource is susceptible to panics when too many fields are added to the set of headers. Wasmtime's implementation in the `wasmtime-wasi-http` crate is backed by a data structure which panics when it reaches excessive capacity and this condition was not handled gracefully in Wasmtime. Panicking in a WASI implementation is a Denial of Service vector for embedders and is treated as a security vulnerability in Wasmtime. ###...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-243v-98vx-264h"
          ],
          "content_hash": "sha256:e993a27fd2a33f70da9696cc0ce051e781e3159707a2d75c7aed05f34bf85ba8"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-770"
            ],
            "packages": [
              "rust:wasmtime",
              "rust:wasmtime",
              "rust:wasmtime",
              "rust:wasmtime"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-243v-98vx-264h"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25882",
        "url": "https://github.com/advisories/GHSA-mrq8-rjmw-wpq3",
        "published_at": "2026-02-24T21:04:07Z",
        "updated_at": "2026-02-24T21:04:08Z",
        "headline": "Fiber has a Denial of Service Vulnerability via Route Parameter Overflow",
        "content": {
          "excerpt_text": "A denial of service vulnerability exists in Fiber v2 and v3 that allows remote attackers to crash the application by sending requests to routes with more than 30 parameters. The vulnerability results from missing validation during route registration combined with an unbounded array write during request matching. ## Affected Versions - **Fiber v3.0.0-rc.3** and earlier v3 releases - **Fiber v2.52.10** and potentially all v2 releases (confirmed exploitable) - Both versions share the same...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-mrq8-rjmw-wpq3"
          ],
          "content_hash": "sha256:ef370cf50b6b05ca02480965ed2955770535fa04dbd0d206863c075d06b6e78c"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-129"
            ],
            "packages": [
              "go:github.com/gofiber/fiber/v2",
              "go:github.com/gofiber/fiber/v3"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-mrq8-rjmw-wpq3"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25899",
        "url": "https://github.com/advisories/GHSA-2mr3-m5q5-wgp6",
        "published_at": "2026-02-24T20:57:25Z",
        "updated_at": "2026-02-24T20:57:27Z",
        "headline": "Fiber is Vulnerable to Denial of Service via Flash Cookie Unbounded Allocation",
        "content": {
          "excerpt_text": "### Summary The use of the `fiber_flash` cookie can force an unbounded allocation on any server. A crafted 10-character cookie value triggers an attempt to allocate up to 85GB of memory via unvalidated msgpack deserialization. No authentication is required. Every GoFiber v3 endpoint is affected regardless of whether the application uses flash messages. ### Details Regardless of configuration, the flash cookie is checked: ```go func (app *App) requestHandler(rctx *fasthttp.RequestCtx) { //...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-2mr3-m5q5-wgp6"
          ],
          "content_hash": "sha256:dd8a65aa280cce4f1950467bede43bceeabd0ed06bf84be39c55b464bd964124"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.5,
            "cwes": [
              "CWE-789"
            ],
            "packages": [
              "go:github.com/gofiber/fiber/v3"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-2mr3-m5q5-wgp6"
            }
          },
          "deprecation": {
            "type": "removal",
            "affects": [
              "func"
            ],
            "confidence": "low",
            "source": "keyword_scan",
            "provenance": {
              "method": "keyword_scan",
              "authority": "GitHub Security Advisories",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-2mr3-m5q5-wgp6"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25891",
        "url": "https://github.com/advisories/GHSA-m3c2-496v-cw3v",
        "published_at": "2026-02-24T20:51:01Z",
        "updated_at": "2026-02-24T20:51:02Z",
        "headline": "Fiber has an Arbitrary File Read in Static Middleware on Windows",
        "content": {
          "excerpt_text": "### Summary **Description** A Path Traversal (CWE-22) vulnerability in Fiber allows a remote attacker to bypass the static middleware sanitizer and read arbitrary files on the server file system on Windows. This affects Fiber v3 through version 3.0.0. This has been patched in Fiber v3 version 3.1.0. ### Details The vulnerability resides in `middleware/static/static.go` within the `sanitizePath` function. This function attempts to sanitize the requested path by checking for backslashes,...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-m3c2-496v-cw3v"
          ],
          "content_hash": "sha256:01ccc9d00dc0467573bb3fe6a6037ad2023102de116cd0b63312c770ee26c961"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-22"
            ],
            "packages": [
              "go:github.com/gofiber/fiber/v3"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-m3c2-496v-cw3v"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27204",
        "url": "https://github.com/advisories/GHSA-852m-cvvp-9p4w",
        "published_at": "2026-02-24T20:47:08Z",
        "updated_at": "2026-02-24T20:47:11Z",
        "headline": "Wasmtime WASI implementations are vulnerable to guest-controlled resource exhaustion",
        "content": {
          "excerpt_text": "### Impact Wasmtime's implementation of WASI host interfaces are susceptible to guest-controlled resource exhaustion on the host. Wasmtime did not appropriately place limits on resource allocations requested by the guests. This serves as a Denial of Service vector where a guest can induce a range of crashing behaviors on the host such as: * Allocating arbitrarily large amounts of host memory. * Causing an allocation failure on the host, which in Rust defaults to aborting the process. *...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-852m-cvvp-9p4w"
          ],
          "content_hash": "sha256:2da4d539e58ea71442ecad66230acc11fbb565eb6cbd1ea190d07c633d103ad2"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-770",
              "CWE-774",
              "CWE-789"
            ],
            "packages": [
              "rust:wasmtime",
              "rust:wasmtime",
              "rust:wasmtime",
              "rust:wasmtime"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-852m-cvvp-9p4w"
            }
          },
          "deprecation": {
            "type": "breaking_change",
            "confidence": "low",
            "source": "keyword_scan",
            "provenance": {
              "method": "keyword_scan",
              "authority": "GitHub Security Advisories",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-852m-cvvp-9p4w"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27195",
        "url": "https://github.com/advisories/GHSA-xjhv-v822-pf94",
        "published_at": "2026-02-24T20:44:46Z",
        "updated_at": "2026-02-24T20:44:46Z",
        "headline": "Wasmtime is vulnerable to panic when dropping a `[Typed]Func::call_async` future",
        "content": {
          "excerpt_text": "The affected versions of Wasmtime can panic if the host embedder drops the future returned by `wasmtime::component::[Typed]Func::call_async` before it resolves. ### Details Starting with Wasmtime 39.0.0, the `component-model-async` feature became the default, which brought with it a new implementation of `[Typed]Func::call_async` which made it capable of calling async-typed guest export functions. However, that implementation had a bug leading to a panic under certain circumstances: 1. The...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-xjhv-v822-pf94"
          ],
          "content_hash": "sha256:0fd604ac60d53774b4d8f3f48f86722c978b5060f4075a2eeaa110db5a57d288"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-755"
            ],
            "packages": [
              "rust:wasmtime",
              "rust:wasmtime"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xjhv-v822-pf94"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27590",
        "url": "https://github.com/advisories/GHSA-5r3v-vc8m-m96g",
        "published_at": "2026-02-24T20:39:08Z",
        "updated_at": "2026-02-24T20:39:14Z",
        "headline": "Caddy: Unicode case-folding length expansion causes incorrect split_path index in FastCGI transport",
        "content": {
          "excerpt_text": "### Summary Caddy's FastCGI path splitting logic computes the split index on a lowercased copy of the request path and then uses that byte index to slice the original path. This is unsafe for Unicode because `strings.ToLower()` can change UTF-8 byte length for some characters. As a result, Caddy can derive an incorrect `SCRIPT_NAME`/`SCRIPT_FILENAME` and `PATH_INFO`, potentially causing a request that contains `.php` to execute a different on-disk file than intended (path confusion). In...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-5r3v-vc8m-m96g"
          ],
          "content_hash": "sha256:88a1614f1cd79a00ad58e807fd8361a619a359f726deecc9f387a49412649d8c"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-20"
            ],
            "packages": [
              "go:github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy/fastcgi"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-5r3v-vc8m-m96g"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27589",
        "url": "https://github.com/advisories/GHSA-879p-475x-rqh2",
        "published_at": "2026-02-24T20:37:35Z",
        "updated_at": "2026-02-24T20:37:36Z",
        "headline": "Caddy is vulnerable to cross-origin config application via local admin API /load",
        "content": {
          "excerpt_text": "commit: e0f8d9b2047af417d8faf354b675941f3dac9891 (as-of 2026-02-04) channel: GitHub security advisory (per SECURITY.md) ## summary The local caddy admin API (default listen `127.0.0.1:2019`) exposes a state-changing `POST /load` endpoint that replaces the entire running configuration. When origin enforcement is not enabled (`enforce_origin` not configured), the admin endpoint accepts cross-origin requests (e.g., from attacker-controlled web content in a victim browser) and applies an...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-879p-475x-rqh2"
          ],
          "content_hash": "sha256:e98694a80ac56629fcbd0169c483754d7d5bf62bf4e8d435624c3b1323fc9c5b"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-352"
            ],
            "packages": [
              "go:github.com/caddyserver/caddy/v2"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-879p-475x-rqh2"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27588",
        "url": "https://github.com/advisories/GHSA-x76f-jf84-rqj8",
        "published_at": "2026-02-24T20:34:01Z",
        "updated_at": "2026-02-24T20:34:04Z",
        "headline": "Caddy: MatchHost becomes case-sensitive for large host lists (>100), enabling host-based route/auth bypass",
        "content": {
          "excerpt_text": "### Summary Caddy's HTTP `host` request matcher is documented as case-insensitive, but when configured with a large host list (>100 entries) it becomes case-sensitive due to an optimized matching path. An attacker can bypass host-based routing and any access controls attached to that route by changing the casing of the `Host` header. ### Details In Caddy `v2.10.2`, the `MatchHost` matcher states it matches the Host value case-insensitively: - `modules/caddyhttp/matchers.go`: `type MatchHost...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-x76f-jf84-rqj8"
          ],
          "content_hash": "sha256:d863f11c65707dbda068affae8f321a1b6ac01930606e30854b6f8bc365b474f"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-178"
            ],
            "packages": [
              "go:github.com/caddyserver/caddy/v2/modules/caddyhttp"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-x76f-jf84-rqj8"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27587",
        "url": "https://github.com/advisories/GHSA-g7pc-pc7g-h8jh",
        "published_at": "2026-02-24T20:31:31Z",
        "updated_at": "2026-02-24T20:31:32Z",
        "headline": "Caddy: MatchPath %xx (escaped-path) branch skips case normalization, enabling path-based route/auth bypass",
        "content": {
          "excerpt_text": "### Summary Caddy's HTTP `path` request matcher is intended to be case-insensitive, but when the match pattern contains percent-escape sequences (`%xx`) it compares against the request's escaped path without lowercasing. An attacker can bypass path-based routing and any access controls attached to that route by changing the casing of the request path. ### Details In Caddy `v2.10.2`, `MatchPath` is explicitly designed to be case-insensitive and lowercases match patterns during provisioning: -...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-g7pc-pc7g-h8jh"
          ],
          "content_hash": "sha256:8362476f3f3c3f2f8316f493f421355108dd83db0fcd03ca0120ea09b99604ad"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-178"
            ],
            "packages": [
              "go:github.com/caddyserver/caddy/v2/modules/caddyhttp"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-g7pc-pc7g-h8jh"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27586",
        "url": "https://github.com/advisories/GHSA-hffm-g8v7-wrv7",
        "published_at": "2026-02-24T20:22:53Z",
        "updated_at": "2026-02-24T20:22:54Z",
        "headline": "Caddy: mTLS client authentication silently fails open when CA certificate file is missing or malformed",
        "content": {
          "excerpt_text": "### Summary Two swallowed errors in `ClientAuthentication.provision()` cause mTLS client certificate authentication to silently fail open when a CA certificate file is missing, unreadable, or malformed. The server starts without error but accepts any client certificate signed by any system-trusted CA, completely bypassing the intended private CA trust boundary. ### Details In `modules/caddytls/connpolicy.go`, the `provision()` method has two `return nil` statements that should be `return...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-hffm-g8v7-wrv7"
          ],
          "content_hash": "sha256:1ba557db199c4636ecc13ec4af6f60fac028d518d55b21c2d1818851d4885ff6"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-755"
            ],
            "packages": [
              "go:github.com/caddyserver/caddy/v2/modules/caddytls"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-hffm-g8v7-wrv7"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27585",
        "url": "https://github.com/advisories/GHSA-4xrr-hq4w-6vf4",
        "published_at": "2026-02-24T20:16:55Z",
        "updated_at": "2026-02-24T20:16:58Z",
        "headline": "Caddy: Improper sanitization of glob characters in file matcher may lead to bypassing security protections",
        "content": {
          "excerpt_text": "### Summary The path sanitization in [file matcher](https://github.com/caddyserver/caddy/blob/68d50020eef0d4c3398b878f17c8092ca5b58ca0/modules/caddyhttp/fileserver/matcher.go#L361) doesn't sanitize backslashes which can lead to bypassing path related security protections. ### Details The [try_files](https://caddyserver.com/docs/caddyfile/directives/try_files) directive is used to rewrite the request uri. It accepts a list of patterns and checks if any files exist in the root that match the...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-4xrr-hq4w-6vf4"
          ],
          "content_hash": "sha256:c6bb6643bbb11e40030b5ec9c214572fe40069f700006548fe80fe308ec70815"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-20"
            ],
            "packages": [
              "go:github.com/caddyserver/caddy/v2/modules/caddyhttp/fileserver"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-4xrr-hq4w-6vf4"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27584",
        "url": "https://github.com/advisories/GHSA-m2cq-xjgm-f668",
        "published_at": "2026-02-24T20:13:30Z",
        "updated_at": "2026-02-24T20:13:32Z",
        "headline": "ActualBudget server is Missing Authentication for SimpleFIN and Pluggy AI bank sync endpoints",
        "content": {
          "excerpt_text": "### Summary Missing authentication middleware in the ActualBudget server component allows any unauthenticated user to query the SimpleFIN and Pluggy.ai integration endpoints and read sensitive bank account balance and transaction information. ### Impact This vulnerability allows an unauthenticated attacker to read the bank account balance and transaction history of ActualBudget users. This vulnerability impacts all ActualBudget Server users with the SimpleFIN or Pluggy.ai integrations...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-m2cq-xjgm-f668"
          ],
          "content_hash": "sha256:1501d12f6e3376b1fc39a1ebf4e69f59481d9487ddc26b0ab7cddd7fcc01709c"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cwes": [
              "CWE-306"
            ],
            "packages": [
              "npm:@actual-app/sync-server"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-m2cq-xjgm-f668"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27567",
        "url": "https://github.com/advisories/GHSA-hhfx-5x8j-f5f6",
        "published_at": "2026-02-24T20:10:32Z",
        "updated_at": "2026-02-24T20:10:33Z",
        "headline": "Payload: Server-Side Request Forgery (SSRF) in External File URL Uploads",
        "content": {
          "excerpt_text": "### Impact A Server-Side Request Forgery (SSRF) vulnerability exists in Payload's external file upload functionality. When processing external URLs for file uploads, insufficient validation of HTTP redirects could allow an authenticated attacker to access internal network resources. **Users are affected if ALL of these are true**: - Payload version < v3.75.0 - At least one collection with `upload` enabled - A user has `create` access to that upload-enabled collection An authenticated user...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-hhfx-5x8j-f5f6"
          ],
          "content_hash": "sha256:53120057da0b046665e52350cfebc15891f070a75efc1e501aac9ffcc1a38849"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.5,
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "npm:payload"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-hhfx-5x8j-f5f6"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27483",
        "url": "https://github.com/advisories/GHSA-4894-xqv6-vrfq",
        "published_at": "2026-02-24T20:07:58Z",
        "updated_at": "2026-02-24T20:07:59Z",
        "headline": "MindsDB: Path Traversal in /api/files Leading to Remote Code Execution",
        "content": {
          "excerpt_text": "### Summary There is a path traversal vulnerability in Mindsdb's /api/files interface, which an authenticated attacker can exploit to achieve remote command execution. ### Details The vulnerability exists in the \"Upload File\" module, which corresponds to the API endpoint /api/files. The affected code is located at mindsdb/api/http/namespaces/file.py: ```python @ns_conf.route(\"/ \") @ns_conf.param(\"name\", \"MindsDB's name for file\") class File(Resource): @ns_conf.doc(\"put_file\")...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-4894-xqv6-vrfq"
          ],
          "content_hash": "sha256:5849c88911fed09a08171d22be979d0cc57b45ed5e44c9ba82985beaa3de963e"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.8,
            "cwes": [
              "CWE-22"
            ],
            "packages": [
              "pip:mindsdb"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-4894-xqv6-vrfq"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27461",
        "url": "https://github.com/advisories/GHSA-vxg3-v4p6-f3fp",
        "published_at": "2026-02-24T20:03:23Z",
        "updated_at": "2026-02-24T20:03:26Z",
        "headline": "Pimcore vulnerable to SQL injection via unsanitized filter value in Dependency Dao RLIKE clause",
        "content": {
          "excerpt_text": "The filter query parameter in the dependency listing endpoints is JSON-decoded and the value field is concatenated directly into RLIKE clauses without sanitization or parameterized queries. Affected code in models/Dependency/Dao.php: - getFilterRequiresByPath() lines 90, 95, 100 - getFilterRequiredByPath() lines 148, 153, 158 All 6 locations use direct string concatenation like: \"AND LOWER(CONCAT(o.path, o.key)) RLIKE '\".$value.\"'\" Note that $orderBy and $orderDirection in the same methods...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-vxg3-v4p6-f3fp"
          ],
          "content_hash": "sha256:3086ce74d9405f45dcd0f5c5632dec8af310af5ee3853712d9148700399531cc"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-89"
            ],
            "packages": [
              "composer:pimcore/pimcore",
              "composer:pimcore/pimcore"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-vxg3-v4p6-f3fp"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27156",
        "url": "https://github.com/advisories/GHSA-78qv-3mpx-9cqq",
        "published_at": "2026-02-24T19:56:18Z",
        "updated_at": "2026-02-24T19:56:19Z",
        "headline": "NiceGUI vulnerable to XSS via Code Injection during client-side element function execution",
        "content": {
          "excerpt_text": "### Summary Several NiceGUI APIs that execute methods on client-side elements (`Element.run_method()`, `AgGrid.run_grid_method()`, `EChart.run_chart_method()`, and others) use an `eval()` fallback in the JavaScript-side `runMethod()` function. When user-controlled input is passed as the method name, an attacker can inject arbitrary JavaScript that executes in the victim's browser. Additionally, `Element.run_method()` and `Element.get_computed_prop()` used string interpolation instead of...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-78qv-3mpx-9cqq"
          ],
          "content_hash": "sha256:40991875c3a98808333fd0f4e5564dc0a8d958f97a7b3ca2c4a98ea79d6c9410"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79"
            ],
            "packages": [
              "pip:nicegui"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-78qv-3mpx-9cqq"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27571",
        "url": "https://github.com/advisories/GHSA-qrvq-68c2-7grw",
        "published_at": "2026-02-24T16:04:53Z",
        "updated_at": "2026-02-24T16:04:58Z",
        "headline": "nats-server websockets are vulnerable to pre-auth memory DoS",
        "content": {
          "excerpt_text": "### Impact The WebSockets handling of NATS messages handles compressed messages via the WebSockets negotiated compression. The implementation bound the memory size of a NATS message but did not independently bound the memory consumption of the memory stream when constructing a NATS message which might then fail validation for size reasons. An attacker can use a compression bomb to cause excessive memory consumption, often resulting in the operating system terminating the server process. The...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-qrvq-68c2-7grw"
          ],
          "content_hash": "sha256:98e9fe2ca01eb5452e116c6a5c0c00b545f9e6bb2018697c7de6c5056b3e0538"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.9,
            "cwes": [
              "CWE-409",
              "CWE-770"
            ],
            "packages": [
              "go:github.com/nats-io/nats-server/v2",
              "go:github.com/nats-io/nats-server/v2",
              "go:github.com/nats-io/nats-server"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-qrvq-68c2-7grw"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27469",
        "url": "https://github.com/advisories/GHSA-9fww-8cpr-q66r",
        "published_at": "2026-02-24T16:03:04Z",
        "updated_at": "2026-02-24T16:03:04Z",
        "headline": "Isso affected by Stored XSS via comment website field",
        "content": {
          "excerpt_text": "## Impact This is a stored Cross-Site Scripting (XSS) vulnerability affecting the website and author comment fields. The website field was HTML-escaped using quote=False, which left single and double quotes unescaped. Since the frontend inserts the website value directly into a single-quoted href attribute via string concatenation, a single quote in the URL breaks out of the attribute context, allowing injection of arbitrary event handlers (e.g. onmouseover, onclick). The same escaping was...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-9fww-8cpr-q66r"
          ],
          "content_hash": "sha256:260c2767bf897868b617ae6ab5bf9bae32f5383c376deefb0fe5715c8eed477b"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.1,
            "cwes": [
              "CWE-79",
              "CWE-116"
            ],
            "packages": [
              "pip:isso"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-9fww-8cpr-q66r"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27574",
        "url": "https://github.com/advisories/GHSA-v264-xqh4-9xmm",
        "published_at": "2026-02-24T16:00:56Z",
        "updated_at": "2026-02-24T16:00:57Z",
        "headline": "OneUptime:: node:vm sandbox escape in probe allows any project member to achieve RCE",
        "content": {
          "excerpt_text": "### Summary OneUptime lets project members write custom JavaScript that runs inside monitors. The problem is it executes that code using Node.js's built-in `vm` module, which Node.js itself documents as \"not a security mechanism — do not use it to run untrusted code.\" The classic one-liner escape gives full access to the underlying process, and since the probe runs with host networking and holds all cluster credentials in its environment, this turns into a full cluster compromise for...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-v264-xqh4-9xmm"
          ],
          "content_hash": "sha256:34b5fb8bb82af32b586378c346db8c85d76b744aec46a3b29d355be3dd64a774"
        },
        "signals": {
          "severity": {
            "level": "critical",
            "source": "github_advisory",
            "cvss": 10.0,
            "cwes": [
              "CWE-94"
            ],
            "packages": [
              "npm:@oneuptime/common"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-v264-xqh4-9xmm"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27129",
        "url": "https://github.com/advisories/GHSA-v2gc-rm6g-wrw9",
        "published_at": "2026-02-24T15:51:07Z",
        "updated_at": "2026-02-24T15:51:09Z",
        "headline": "Craft CMS: Cloud Metadata SSRF Protection Bypass via IPv6 Resolution",
        "content": {
          "excerpt_text": "The SSRF validation in Craft CMS’s GraphQL Asset mutation uses `gethostbyname()`, which only resolves IPv4 addresses. When a hostname has only AAAA (IPv6) records, the function returns the hostname string itself, causing the blocklist comparison to always fail and completely bypassing SSRF protection. This is a bypass of the security fix for CVE-2025-68437 ([GHSA-x27p-wfqw-hfcc](https://github.com/craftcms/cms/security/advisories/GHSA-x27p-wfqw-hfcc)). ## Required Permissions Exploitation...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-v2gc-rm6g-wrw9"
          ],
          "content_hash": "sha256:ce54140402607476bbd5e8480494b0f565ea4b792ba35052b3d06a8d619f1cc2"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-918"
            ],
            "packages": [
              "composer:craftcms/cms",
              "composer:craftcms/cms"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-v2gc-rm6g-wrw9"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-26983",
        "url": "https://github.com/advisories/GHSA-w8mw-frc6-r7m8",
        "published_at": "2026-02-24T15:46:49Z",
        "updated_at": "2026-02-24T15:46:51Z",
        "headline": "ImageMagick: Invalid MSL <map> can result in a use after free",
        "content": {
          "excerpt_text": "The MSL interpreter crashes when processing a invalid ` ` element that causes it to use an image after it has been freed.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-w8mw-frc6-r7m8"
          ],
          "content_hash": "sha256:840ec64476bd79ecc08824d278857e2cdf6bade6eefe987d366a612063882649"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-476"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-w8mw-frc6-r7m8"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-26283",
        "url": "https://github.com/advisories/GHSA-gwr3-x37h-h84v",
        "published_at": "2026-02-24T15:46:25Z",
        "updated_at": "2026-02-24T15:46:26Z",
        "headline": "ImageMagick has a possible infinite loop in its JPEG encoder when using `jpeg:extent`",
        "content": {
          "excerpt_text": "A `continue` statement in the JPEG extent binary search loop in the jpeg encoder causes an infinite loop when writing persistently fails. An attacker can trigger a 100% CPU consumption and process hang (Denial of Service) with a crafted image.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-gwr3-x37h-h84v"
          ],
          "content_hash": "sha256:8296f74da9f6f9a165bf5dc414ee4fcd0f3a6829ebfcfb08ebf3033412f26fd2"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.2,
            "cwes": [
              "CWE-835"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-gwr3-x37h-h84v"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-26066",
        "url": "https://github.com/advisories/GHSA-v994-63cg-9wj3",
        "published_at": "2026-02-24T15:46:03Z",
        "updated_at": "2026-02-24T15:46:05Z",
        "headline": "ImageMagick has infinite loop when writing IPTCTEXT leads to denial of service via crafted profile",
        "content": {
          "excerpt_text": "A crafted profile contain invalid IPTC data may cause an infinite loop when writing it with `IPTCTEXT`.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-v994-63cg-9wj3"
          ],
          "content_hash": "sha256:27890ca65e174f4f55ef23e0baaca6c18d8cded250139c126f62a22ad050f3e1"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.2,
            "cwes": [
              "CWE-400",
              "CWE-835"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-v994-63cg-9wj3"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25989",
        "url": "https://github.com/advisories/GHSA-7355-pwx2-pm84",
        "published_at": "2026-02-24T15:45:35Z",
        "updated_at": "2026-02-24T15:45:37Z",
        "headline": "ImageMagick: Integer overflow or wraparound and incorrect conversion between numeric types in the internal SVG decoder",
        "content": {
          "excerpt_text": "A crafted SVG file can cause a denial of service. An off-by-one boundary check (`>` instead of `>=`) that allows bypass the guard and reach an undefined `(size_t)` cast.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-7355-pwx2-pm84"
          ],
          "content_hash": "sha256:9e3a495eaa088fc60e6b73e659aa9aa106ec0eed823839fd14ed2f671cc6a41d"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.5,
            "cwes": [
              "CWE-190",
              "CWE-681"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-7355-pwx2-pm84"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25988",
        "url": "https://github.com/advisories/GHSA-782x-jh29-9mf7",
        "published_at": "2026-02-24T15:45:13Z",
        "updated_at": "2026-02-24T15:45:15Z",
        "headline": "ImageMagick: MSL image stack index may fail to refresh, leading to leaked images",
        "content": {
          "excerpt_text": "Sometimes msl.c fails to update the stack index, so an image is stored in the wrong slot and never freed on error, causing leaks. ``` ==841485==ERROR: LeakSanitizer: detected memory leaks Direct leak of 13512 byte(s) in 1 object(s) allocated from: #0 0x7ff330759887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-782x-jh29-9mf7"
          ],
          "content_hash": "sha256:afbac94d6d6b665ecd8ef29a0bdbf4f1e592b5eb005ce59f076cbb6cfbba779e"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-782x-jh29-9mf7"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25987",
        "url": "https://github.com/advisories/GHSA-42p5-62qq-mmh7",
        "published_at": "2026-02-24T15:44:47Z",
        "updated_at": "2026-02-24T15:44:50Z",
        "headline": "ImageMagick has a heap buffer over-read in its MAP image decoder",
        "content": {
          "excerpt_text": "A heap buffer over-read vulnerability exists in the MAP image decoder when processing crafted MAP files, potentially leading to crashes or unintended memory disclosure during image decoding. ``` ================================================================= ==4070926==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000002b31 at pc 0x56517afbd910 bp 0x7ffc59e90000 sp 0x7ffc59e8fff0 READ of size 1 at 0x502000002b31 thread T0 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-42p5-62qq-mmh7"
          ],
          "content_hash": "sha256:c0a3e1387b7e14e801769d4d12a58c0ff802a563432e2dbfc6c10f7ade55f177"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-125"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-42p5-62qq-mmh7"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25985",
        "url": "https://github.com/advisories/GHSA-v7g2-m8c5-mf84",
        "published_at": "2026-02-24T15:44:19Z",
        "updated_at": "2026-02-24T15:44:21Z",
        "headline": "ImageMagick: Memory allocation with excessive without limits in the internal SVG decoder",
        "content": {
          "excerpt_text": "A crafted SVG file containing an malicious element causes ImageMagick to attempt to allocate ~674 GB of memory, leading to an out-of-memory abort. Found via AFL++ fuzzing with afl-clang-lto instrumentation and AddressSanitizer.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-v7g2-m8c5-mf84"
          ],
          "content_hash": "sha256:c65cee561dcdc8bd4e8f8e6124afdee26f8648d76f11576a7632aadb98f9e08e"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.5,
            "cwes": [
              "CWE-770",
              "CWE-789"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-v7g2-m8c5-mf84"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25983",
        "url": "https://github.com/advisories/GHSA-fwqw-2x5x-w566",
        "published_at": "2026-02-24T15:43:54Z",
        "updated_at": "2026-02-24T15:43:55Z",
        "headline": "ImageMagick has Use After Free in MSLStartElement in \"coders/msl.c\"",
        "content": {
          "excerpt_text": "A crafted MSL script triggers a heap-use-after-free. The operation element handler replaces and frees the image while the parser continues reading from it, leading to a UAF in ReadBlobString during further parsing.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-fwqw-2x5x-w566"
          ],
          "content_hash": "sha256:b3439c4fc75c7390dd54c87317df5a8f3a35bee6ebda59819b35999d5e5a3d75"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-416"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-fwqw-2x5x-w566"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25969",
        "url": "https://github.com/advisories/GHSA-xgm3-v4r9-wfgm",
        "published_at": "2026-02-24T15:43:28Z",
        "updated_at": "2026-02-24T15:43:30Z",
        "headline": "Image Magick has a Memory Leak in coders/ashlar.c",
        "content": {
          "excerpt_text": "Memory leak exists in `coders/ashlar.c`. The `WriteASHLARImage` allocates a structure. However, when an exception is thrown, the allocated memory is not properly released, resulting in a potential memory leak. ``` ```bash ==78968== Memcheck, a memory error detector ==78968== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al. ==78968== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info ==78968== ==78968== HEAP SUMMARY: ==78968== in use at exit: 17,232 bytes in 4...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-xgm3-v4r9-wfgm"
          ],
          "content_hash": "sha256:6c0a0bd7c7c35914b386206fbfdd351108f5a45ef3bbdadd3c0fc23e41d7de0f"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xgm3-v4r9-wfgm"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25967",
        "url": "https://github.com/advisories/GHSA-72hf-fj62-w6j4",
        "published_at": "2026-02-24T15:43:02Z",
        "updated_at": "2026-02-24T15:43:05Z",
        "headline": "ImageMagick: Stack buffer overflow in FTXT reader via oversized integer field",
        "content": {
          "excerpt_text": "### Summary A stack-based buffer overflow exists in the ImageMagick FTXT image reader. A crafted FTXT file can cause out-of-bounds writes on the stack, leading to a crash. ``` ================================================================= ==3537074==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffee4850ef0 at pc 0x5607c408fb33 bp 0x7ffee484fe50 sp 0x7ffee484fe40 WRITE of size 1 at 0x7ffee4850ef0 thread T0 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-72hf-fj62-w6j4"
          ],
          "content_hash": "sha256:9a95a995b4e8d7decf2cf08e2c552d8325c7f057004edb4a1c89a8ff869e55b4"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.4,
            "cwes": [
              "CWE-121"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-72hf-fj62-w6j4"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25966",
        "url": "https://github.com/advisories/GHSA-xwc6-v6g8-pw2h",
        "published_at": "2026-02-24T15:42:37Z",
        "updated_at": "2026-02-24T15:42:39Z",
        "headline": "ImageMagick's Security Policy Bypass through config/policy-secure.xml via \"fd handler\" leads to stdin/stdout access",
        "content": {
          "excerpt_text": "The shipped “secure” security policy includes a rule intended to prevent reading/writing from standard streams: ```xml ``` However, ImageMagick also supports fd: pseudo-filenames (e.g., fd:0, fd:1). This path form is not blocked by the secure policy templates, and therefore bypasses the protection goal of “no stdin/stdout”. To resolve this, users can add the following change to their security policy. ```xml ``` And this will also be included in ImageMagick's more secure policies by default.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-xwc6-v6g8-pw2h"
          ],
          "content_hash": "sha256:024905c0412f1d36efe6e7c1fe9af97ecc5e93ec1cf445d0ded61c87fe009f69"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.9,
            "cwes": [
              "CWE-284"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86",
              "nuget:Magick.NET-Q16-arm64"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-xwc6-v6g8-pw2h"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25965",
        "url": "https://github.com/advisories/GHSA-8jvj-p28h-9gm7",
        "published_at": "2026-02-24T15:40:06Z",
        "updated_at": "2026-02-24T15:40:08Z",
        "headline": "ImageMagick: Policy bypass through path traversal allows reading restricted content despite secured policy",
        "content": {
          "excerpt_text": "ImageMagick’s path security policy is enforced on the raw filename string before the filesystem resolves it. As a result, a policy rule such as /etc/* can be bypassed by a path traversal. The OS resolves the traversal and opens the sensitive file, but the policy matcher only sees the unnormalized path and therefore allows the read. This enables local file disclosure (LFI) even when policy-secure.xml is applied. Actions to prevent reading from files have been taken. But it make sure writing...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-8jvj-p28h-9gm7"
          ],
          "content_hash": "sha256:5b2654d907bff905fc03a7ac27710f951a204ab951462f7489cc40190af0a385"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.6,
            "cwes": [
              "CWE-22"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-8jvj-p28h-9gm7"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25898",
        "url": "https://github.com/advisories/GHSA-vpxv-r9pg-7gpr",
        "published_at": "2026-02-24T15:39:11Z",
        "updated_at": "2026-02-24T15:39:16Z",
        "headline": "ImageMagick has Global Buffer Overflow (OOB Read) via Negative Pixel Index in UIL and XPM Writer",
        "content": {
          "excerpt_text": "The UIL and XPM image encoder do not validate the pixel index value returned by `GetPixelIndex()` before using it as an array subscript. In HDRI builds, `Quantum` is a floating-point type, so pixel index values can be negative. An attacker can craft an image with negative pixel index values to trigger a global buffer overflow read during conversion, leading to information disclosure or a process crash. ``` READ of size 1 at 0x55a8823a776e thread T0 #0 0x55a880d01e85 in WriteUILImage...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-vpxv-r9pg-7gpr"
          ],
          "content_hash": "sha256:36905e06c1594d20f4ef401c878a5e42b75fa4183c75bb810650f3ba08901928"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.5,
            "cwes": [
              "CWE-125"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86",
              "nuget:Magick.NET-Q16-arm64"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-vpxv-r9pg-7gpr"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25897",
        "url": "https://github.com/advisories/GHSA-6j5f-24fw-pqp4",
        "published_at": "2026-02-24T15:38:35Z",
        "updated_at": "2026-02-24T15:38:37Z",
        "headline": "ImageMagick: Heap overflow in sun decoder on 32-bit systems may result in out of bounds write",
        "content": {
          "excerpt_text": "An Integer Overflow vulnerability exists in the sun decoder. On 32-bit systems/builds, a carefully crafted image can lead to an out of bounds heap write. ``` ================================================================= ==1967675==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf190b50e at pc 0x5eae8777 bp 0xffb0fdd8 sp 0xffb0fdd0 WRITE of size 1 at 0xf190b50e thread T0 ```",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-6j5f-24fw-pqp4"
          ],
          "content_hash": "sha256:185df46ec2a0c266b0a6ab6710112d3dc0bd5f98a218dced47c29d8b2d4a591e"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.5,
            "cwes": [
              "CWE-122"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-6j5f-24fw-pqp4"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25799",
        "url": "https://github.com/advisories/GHSA-543g-8grm-9cw6",
        "published_at": "2026-02-24T15:37:53Z",
        "updated_at": "2026-02-24T15:37:56Z",
        "headline": "ImageMagick has Division-by-Zero in YUV sampling factor validation, which leads to crash",
        "content": {
          "excerpt_text": "A logic error in YUV sampling factor validation allows an invalid sampling factor to bypass checks and trigger a division-by-zero during image loading, resulting in a reliable denial-of-service. ``` coders/yuv.c:210:47: runtime error: division by zero AddressSanitizer:DEADLYSIGNAL ================================================================= ==3543373==ERROR: AddressSanitizer: UNKNOWN SIGNAL on unknown address 0x000000000000 (pc 0x55deeb4d723c bp 0x7fffc28d34d0 sp 0x7fffc28d3320 T0) #0...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-543g-8grm-9cw6"
          ],
          "content_hash": "sha256:5b324f93d6ad866150c584cb91692df4c813ec9a607a93a7cdfa697efe4359af"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-369"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-543g-8grm-9cw6"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25798",
        "url": "https://github.com/advisories/GHSA-p863-5fgm-rgq4",
        "published_at": "2026-02-24T15:36:08Z",
        "updated_at": "2026-02-24T15:36:10Z",
        "headline": "ImageMagick has NULL Pointer Dereference in ClonePixelCacheRepository via crafted image",
        "content": {
          "excerpt_text": "A NULL pointer dereference in ClonePixelCacheRepository allows a remote attacker to crash any application linked against ImageMagick by supplying a crafted image file, resulting in Denial of Service. ``` AddressSanitizer:DEADLYSIGNAL ================================================================= ==3704942==ERROR: AddressSanitizer: UNKNOWN SIGNAL on unknown address 0x000000000000 (pc 0x7f9d141239e0 bp 0x7ffd4c5711e0 sp 0x7ffd4c571148 T0) #0 0x7f9d141239e0...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-p863-5fgm-rgq4"
          ],
          "content_hash": "sha256:9862f7c023ad4d172d40a00ffbc2737ad87561612cd0abdb1dc6b93afe0894e0"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-476"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-p863-5fgm-rgq4"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25797",
        "url": "https://github.com/advisories/GHSA-rw6c-xp26-225v",
        "published_at": "2026-02-24T15:34:26Z",
        "updated_at": "2026-02-24T15:34:27Z",
        "headline": "ImageMagick: Code Injection via PostScript header in ps coders",
        "content": {
          "excerpt_text": "The ps encoders, responsible for writing PostScript files, fails to sanitize the input before writing it into the PostScript header. An attacker can provide a malicious file and inject arbitrary PostScript code. When the resulting file is processed by a printer or a viewer (like Ghostscript), the injected code is interpreted and executed. The html encoder does not properly escape strings that are written to in the html document. An attacker can provide a malicious file and injection...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-rw6c-xp26-225v"
          ],
          "content_hash": "sha256:3346e1983ba81e2312e98f034a8aadf85a3a1aa470b90303032a08933366e2c5"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.7,
            "cwes": [
              "CWE-94"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86",
              "nuget:Magick.NET-Q16-arm64"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-rw6c-xp26-225v"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25796",
        "url": "https://github.com/advisories/GHSA-g2pr-qxjg-7r2w",
        "published_at": "2026-02-24T15:33:56Z",
        "updated_at": "2026-02-24T15:34:00Z",
        "headline": "ImageMagick has memory leak of watermark Image object in ReadSTEGANOImage on multiple error/early-return paths",
        "content": {
          "excerpt_text": "### Summary In `ReadSTEGANOImage()` (`coders/stegano.c`), the `watermark` Image object is not freed on three early-return paths, resulting in a definite memory leak (~13.5KB+ per invocation) that can be exploited for denial of service. ``` Direct leak of 13512 byte(s) in 1 object(s) allocated from: #0 0x7f5c11e27887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 #1 0x55cdc38f65c4 in AcquireMagickMemory MagickCore/memory.c:536 #2 0x55cdc38f65eb in...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-g2pr-qxjg-7r2w"
          ],
          "content_hash": "sha256:0d2d22a1767688ecca2b685e9625e87509bee3eb85a911acb2bb02a8ba292509"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-g2pr-qxjg-7r2w"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25795",
        "url": "https://github.com/advisories/GHSA-p33r-fqw2-rqmm",
        "published_at": "2026-02-24T15:32:34Z",
        "updated_at": "2026-02-24T15:32:39Z",
        "headline": "ImageMagick has NULL pointer dereference in ReadSFWImage after DestroyImageInfo (sfw.c)",
        "content": {
          "excerpt_text": "In `ReadSFWImage()` (`coders/sfw.c`), when temporary file creation fails, `read_info` is destroyed before its `filename` member is accessed, causing a NULL pointer dereference and crash. ``` AddressSanitizer:DEADLYSIGNAL ================================================================= ==1414421==ERROR: AddressSanitizer: UNKNOWN SIGNAL on unknown address 0x000000000000 (pc 0x56260222912f bp 0x7ffec0a193b0 sp 0x7ffec0a19360 T0) #0 0x56260222912f...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-p33r-fqw2-rqmm"
          ],
          "content_hash": "sha256:974463651920d9e4d00f698e0dee560c41714a286a99bc38bd22c732295c8744"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-476"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-p33r-fqw2-rqmm"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25794",
        "url": "https://github.com/advisories/GHSA-vhqj-f5cj-9x8h",
        "published_at": "2026-02-24T15:31:57Z",
        "updated_at": "2026-02-24T15:31:59Z",
        "headline": "ImageMagick has heap-buffer-overflow via signed integer overflow in WriteUHDRImage when writing UHDR images with large dimensions",
        "content": {
          "excerpt_text": "`WriteUHDRImage` in `coders/uhdr.c` uses `int` arithmetic to compute the pixel buffer size. When image dimensions are large, the multiplication overflows 32-bit `int`, causing an undersized heap allocation followed by an out-of-bounds write. This can crash the process or potentially lead to an out of bounds heap write. ``` ==1575126==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7fc382ef3820 at pc 0x5560d31f229f bp 0x7ffe865f9530 sp 0x7ffe865f9520 WRITE of size 8 at...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-vhqj-f5cj-9x8h"
          ],
          "content_hash": "sha256:c41baf4cc2543bad64a38dbf4e7faec1a844d659302811df97029897c404d26f"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.2,
            "cwes": [
              "CWE-122",
              "CWE-190"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-vhqj-f5cj-9x8h"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25638",
        "url": "https://github.com/advisories/GHSA-gxcx-qjqp-8vjw",
        "published_at": "2026-02-24T15:30:54Z",
        "updated_at": "2026-02-24T15:30:59Z",
        "headline": "ImageMagick has memory leak in msl encoder",
        "content": {
          "excerpt_text": "Memory leak exists in `coders/msl.c`. In the `WriteMSLImage` function of the `msl.c` file, resources are allocated. But the function returns early without releasing these allocated resources. ``` ==78983== Memcheck, a memory error detector ==78983== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al. ==78983== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info ==78983== ==78983== 177,196 (13,512 direct, 163,684 indirect) bytes in 1 blocks are definitely lost in...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-gxcx-qjqp-8vjw"
          ],
          "content_hash": "sha256:d259cbf5b46cd5516eb7b1658bd6566eb3fcfc8966653e8fe9fa766fad122954"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-gxcx-qjqp-8vjw"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25637",
        "url": "https://github.com/advisories/GHSA-gm37-qx7w-p258",
        "published_at": "2026-02-24T15:30:16Z",
        "updated_at": "2026-02-24T15:30:17Z",
        "headline": "ImageMagick: Possible memory leak in ASHLAR encoder",
        "content": {
          "excerpt_text": "A memory leak in the ASHLAR image writer allows an attacker to exhaust process memory by providing a crafted image that results in small objects that are allocated but never freed. ``` ==880062== Memcheck, a memory error detector ==880062== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==880062== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info ==880062== ==880062== ==880062== HEAP SUMMARY: ==880062== in use at exit: 386,826 bytes in 696 blocks ==880062==...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-gm37-qx7w-p258"
          ],
          "content_hash": "sha256:62d55f3c08d23a0a602ea8d0525e8f033357bf53f89ae4ee49b60738e5394f8f"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-401"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-gm37-qx7w-p258"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-25576",
        "url": "https://github.com/advisories/GHSA-jv4p-gjwq-9r2j",
        "published_at": "2026-02-24T15:29:46Z",
        "updated_at": "2026-02-24T15:29:48Z",
        "headline": "ImageMagick: Out of bounds read in multiple coders read raw pixel data",
        "content": {
          "excerpt_text": "A heap buffer over-read vulnerability exists in multiple raw image format handles. The vulnerability occurs when processing images with -extract dimensions larger than -size dimensions, causing out-of-bounds memory reads from a heap-allocated buffer.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-jv4p-gjwq-9r2j"
          ],
          "content_hash": "sha256:815a3153d25e6b37a572b646a5bf2e3fb38bedcff588b1245afcfef91f05e537"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.1,
            "cwes": [
              "CWE-122"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86",
              "nuget:Magick.NET-Q16-arm64"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-jv4p-gjwq-9r2j"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-24485",
        "url": "https://github.com/advisories/GHSA-pqgj-2p96-rx85",
        "published_at": "2026-02-24T15:29:12Z",
        "updated_at": "2026-02-24T15:29:16Z",
        "headline": "ImageMagick: Infinite loop vulnerability when parsing a PCD file",
        "content": {
          "excerpt_text": "When a PCD file does not contain a valid marker, the DecodeImage() function becomes trapped in an infinite loop while searching for the marker, causing the program to become unresponsive and continuously consume CPU resources, ultimately leading to system resource exhaustion and denial of service.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-pqgj-2p96-rx85"
          ],
          "content_hash": "sha256:24e8cdd8aac36284d6fb5c93a8c2ce01f0d9a8cd23b005ec1e28067b3bf3eb3e"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.5,
            "cwes": [
              "CWE-400"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-pqgj-2p96-rx85"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-24484",
        "url": "https://github.com/advisories/GHSA-wg3g-gvx5-2pmv",
        "published_at": "2026-02-24T15:28:17Z",
        "updated_at": "2026-02-24T15:28:21Z",
        "headline": "ImageMagick: Converting multi-layer nested MVG to SVG can cause DoS",
        "content": {
          "excerpt_text": "Magick fails to check for multi-layer nested mvg conversions to svg, leading to DoS.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-wg3g-gvx5-2pmv"
          ],
          "content_hash": "sha256:455b7ccd62549a518803c1684e86782c6cfe627846a0f22a2857cb16d516992e"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 5.3,
            "cwes": [
              "CWE-400"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-OpenMP-x86"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-wg3g-gvx5-2pmv"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-24481",
        "url": "https://github.com/advisories/GHSA-96pc-27rx-pr36",
        "published_at": "2026-02-24T15:27:28Z",
        "updated_at": "2026-02-24T15:27:31Z",
        "headline": "ImageMagick has Possible Heap Information Disclosure in PSD ZIP Decompression",
        "content": {
          "excerpt_text": "### Description A heap information disclosure vulnerability exists in ImageMagick's PSD (Adobe Photoshop) format handler. When processing a maliciously crafted PSD file containing ZIP-compressed layer data that decompresses to less than the expected size, uninitialized heap memory is leaked into the output image. ### Expected Impact Information disclosure leading to potential exposure of sensitive data from server memory.",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-96pc-27rx-pr36"
          ],
          "content_hash": "sha256:9ba551b0be87e8015121af86123aef33d462cebe22782b409507d830e37cc6a9"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 7.5,
            "cwes": [
              "CWE-125"
            ],
            "packages": [
              "nuget:Magick.NET-Q16-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-AnyCPU",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-arm64",
              "nuget:Magick.NET-Q16-HDRI-OpenMP-x64",
              "nuget:Magick.NET-Q16-HDRI-arm64",
              "nuget:Magick.NET-Q16-HDRI-x64",
              "nuget:Magick.NET-Q16-HDRI-x86",
              "nuget:Magick.NET-Q16-OpenMP-arm64",
              "nuget:Magick.NET-Q16-OpenMP-x64",
              "nuget:Magick.NET-Q16-arm64"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-96pc-27rx-pr36"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2025-27555",
        "url": "https://github.com/advisories/GHSA-8r55-rv5w-6pfm",
        "published_at": "2026-02-24T12:31:40Z",
        "updated_at": "2026-02-25T19:21:33Z",
        "headline": "Apache Airflow exposes sensitive information in its log files",
        "content": {
          "excerpt_text": "Airflow versions before 2.11.1 have a vulnerability that allows authenticated users with audit log access to see sensitive values in audit logs which they should not see. When sensitive connection parameters were set via airflow CLI, values of those variables appeared in the audit log and were stored unencrypted in the Airflow database. While this risk is limited to users with audit log access, it is recommended to upgrade to Airflow 2.11.1 or a later version, which addresses this issue....",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-8r55-rv5w-6pfm"
          ],
          "content_hash": "sha256:065ed68b9d28c2f7853ae7764a94377bc9d68f39e904c20ff61f919aaf5729b7"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cvss": 6.5,
            "cwes": [
              "CWE-201",
              "CWE-532"
            ],
            "packages": [
              "pip:apache-airflow"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-8r55-rv5w-6pfm"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2024-56373",
        "url": "https://github.com/advisories/GHSA-r837-hpv7-pc2f",
        "published_at": "2026-02-24T12:31:40Z",
        "updated_at": "2026-02-25T19:20:57Z",
        "headline": "Apache Airflow vulnerable to Code Injection in the web-server context via LogTemplate table",
        "content": {
          "excerpt_text": "DAG Author (who already has quite a lot of permissions) could manipulate database of Airflow 2 in the way to execute arbitrary code in the web-server context, which they should normally not be able to do, leading to potentially remote code execution in the context of web-server (server-side) as a result of a user viewing historical task information. The functionality responsible for that (log template history) has been disabled by default in 2.11.1 and users should upgrade to Airflow 3 if...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-r837-hpv7-pc2f"
          ],
          "content_hash": "sha256:1e441d58dc7839d50c051e2e0efa8b60c14d4995e72f9a9bdc7d5824a45a1972"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cvss": 8.5,
            "cwes": [
              "CWE-94"
            ],
            "packages": [
              "pip:apache-airflow"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-r837-hpv7-pc2f"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27128",
        "url": "https://github.com/advisories/GHSA-6fx5-5cw5-4897",
        "published_at": "2026-02-23T22:16:22Z",
        "updated_at": "2026-02-24T16:08:49Z",
        "headline": "Craft CMS Race condition in Token Service potentially allows for token usage greater than the token limit",
        "content": {
          "excerpt_text": "A Time-of-Check-Time-of-Use (TOCTOU) race condition exists in Craft CMS’s token validation service for tokens that explicitly set a limited usage. The `getTokenRoute()` method reads a token’s usage count, checks if it’s within limits, then updates the database in separate non-atomic operations. By sending concurrent requests, an attacker can use a single-use impersonation token multiple times before the database update completes. To make this work, an attacker needs to obtain a valid...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-6fx5-5cw5-4897"
          ],
          "content_hash": "sha256:a7534c23a4624123090b9e3de1dd17ad913e9425db6982302464beef688c9030"
        },
        "signals": {
          "severity": {
            "level": "medium",
            "source": "github_advisory",
            "cwes": [
              "CWE-367"
            ],
            "packages": [
              "composer:craftcms/cms",
              "composer:craftcms/cms"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-6fx5-5cw5-4897"
            }
          }
        }
      },
      {
        "source": "github_advisories",
        "id": "CVE-2026-27127",
        "url": "https://github.com/advisories/GHSA-gp2f-7wcm-5fhx",
        "published_at": "2026-02-23T22:16:01Z",
        "updated_at": "2026-02-23T22:16:04Z",
        "headline": "Craft CMS has Cloud Metadata SSRF Protection Bypass via DNS Rebinding",
        "content": {
          "excerpt_text": "## Summary The SSRF validation in Craft CMS’s GraphQL Asset mutation performs DNS resolution **separately** from the HTTP request. This Time-of-Check-Time-of-Use (TOCTOU) vulnerability enables DNS rebinding attacks, where an attacker’s DNS server returns different IP addresses for validation compared to the actual request. This is a bypass of the security fix for CVE-2025-68437 ([GHSA-x27p-wfqw-hfcc](https://github.com/craftcms/cms/security/advisories/GHSA-x27p-wfqw-hfcc)) that allows...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-25T19:58:11Z",
          "evidence_urls": [
            "https://github.com/advisories/GHSA-gp2f-7wcm-5fhx"
          ],
          "content_hash": "sha256:f8d2a886dc655253294740a755c79a99149cf75850e8d1612e5f0894cfa57507"
        },
        "signals": {
          "severity": {
            "level": "high",
            "source": "github_advisory",
            "cwes": [
              "CWE-367"
            ],
            "packages": [
              "composer:craftcms/cms",
              "composer:craftcms/cms"
            ],
            "provenance": {
              "method": "advisory_api",
              "authority": "GitHub Advisory Database",
              "authority_url": "https://github.com/advisories",
              "evidence_url": "https://github.com/advisories/GHSA-gp2f-7wcm-5fhx"
            }
          }
        }
      }
    ],
    "updated": [],
    "removed": []
  },
  "counts": {
    "items": 100,
    "updated": 0,
    "removed": 0
  },
  "integrity_reset": false,
  "archive_url": "/archive/github_advisories/2026/02/25/20260225T195811Z_9424d85b69c59ae7.json",
  "prev_archive_url": "/archive/github_advisories/2026/02/10/20260210T142802Z_0d53e07ce074c901.json",
  "sources_url": "/diff/sources.json"
}
