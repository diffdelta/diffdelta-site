{
  "schema_version": "1.2.0",
  "generated_at": "2026-02-06T03:41:59Z",
  "source_id": "linux_kernel_cve",
  "hash": "sha256:f5a41ca8b933908a0d832e4277056bba2f50e9896ffbf472bf30f742654c26db",
  "prev_hash": "sha256:0000000000000000000000000000000000000000000000000000000000000000",
  "cursor": "sha256:9939b4d6085f52ff62ceb234ec2d10ef3e997f7f569598be68efa4096bdc90aa",
  "prev_cursor": "sha256:0000000000000000000000000000000000000000000000000000000000000000",
  "changed": true,
  "ttl_sec": 3600,
  "sources_included": [
    "linux_kernel_cve"
  ],
  "batch_narrative": "linux_kernel_cve: 25 changes (25 new).",
  "buckets": {
    "new": [
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:941824ca-b4a4-1246-df3e-0de79b3d3f25",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020424-CVE-2026-23089-760f@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:22:06Z",
        "headline": "CVE-2026-23089: ALSA: usb-audio: Fix use-after-free in snd_usb_mixer_free()",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Fix use-after-free in snd_usb_mixer_free() When snd_usb_create_mixer() fails, snd_usb_mixer_free() frees mixer->id_elems but the controls already added to the card still reference the freed memory. Later when snd_card_register() runs, the OSS mixer layer calls their callbacks and hits a use-after-free read. Call trace:...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020424-CVE-2026-23089-760f@gregkh/"
          ],
          "content_hash": "sha256:1a02387b7c8063bbf8bd1654db6e4d45d76a1cd1e15bdb9537740cf2c8896a67"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:38b704ec-de26-f20a-910b-b15acdf7a8b0",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020427-CVE-2026-23098-1fd2@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:22:03Z",
        "headline": "CVE-2026-23098: netrom: fix double-free in nr_route_frame()",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: netrom: fix double-free in nr_route_frame() In nr_route_frame(), old_skb is immediately freed without checking if nr_neigh->ax25 pointer is NULL. Therefore, if nr_neigh->ax25 is NULL, the caller function will free old_skb again, causing a double-free bug. Therefore, to prevent this, we need to modify it to check whether nr_neigh->ax25 is NULL before freeing...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020427-CVE-2026-23098-1fd2@gregkh/"
          ],
          "content_hash": "sha256:144f3d97ba106b50e71e208f4e26f2ed42c90eef72f122019efe6a86d15caf70"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:c5d83a08-a6ba-8e4c-978f-8b49e0f76d39",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020427-CVE-2026-23097-a591@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:59Z",
        "headline": "CVE-2026-23097: migrate: correct lock ordering for hugetlb file folios",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: migrate: correct lock ordering for hugetlb file folios Syzbot has found a deadlock (analyzed by Lance Yang): 1) Task (5749): Holds folio_lock, then tries to acquire i_mmap_rwsem(read lock). 2) Task (5754): Holds i_mmap_rwsem(write lock), then tries to acquire folio_lock. migrate_pages() -> migrate_hugetlbs() -> unmap_and_move_huge_page() <- Takes...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020427-CVE-2026-23097-a591@gregkh/"
          ],
          "content_hash": "sha256:88bfc77c7a3fba0b7c32260515ce30331410dac32463bfbd973c9696a0b43a18"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:405ff7d6-a460-88db-1e2f-1e07fa068e6f",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020427-CVE-2026-23096-e5af@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:56Z",
        "headline": "CVE-2026-23096: uacce: fix cdev handling in the cleanup path",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: uacce: fix cdev handling in the cleanup path When cdev_device_add fails, it internally releases the cdev memory, and if cdev_device_del is then executed, it will cause a hang error. To fix it, we check the return value of cdev_device_add() and clear uacce->cdev to avoid calling cdev_device_del in the uacce_remove. The Linux kernel CVE team has assigned...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020427-CVE-2026-23096-e5af@gregkh/"
          ],
          "content_hash": "sha256:2703ebe17b4e2eec5fbd3c07fb4f4bc9f8d990c3da212e95e90193570bcd74e0"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:77c31bbe-11ab-346e-a7ca-da07672be409",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020426-CVE-2026-23095-66e8@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:53Z",
        "headline": "CVE-2026-23095: gue: Fix skb memleak with inner IP protocol 0.",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: gue: Fix skb memleak with inner IP protocol 0. syzbot reported skb memleak below. [0] The repro generated a GUE packet with its inner protocol 0. gue_udp_recv() returns -guehdr->proto_ctype for \"resubmit\" in ip_protocol_deliver_rcu(), but this only works with non-zero protocol number. Let's drop such packets. Note that 0 is a valid number (IPv6 Hop-by-Hop...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020426-CVE-2026-23095-66e8@gregkh/"
          ],
          "content_hash": "sha256:4138695558317df263d5956536c76d3e591ff96d222c939147a1fa929400a105"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:037d7069-0f63-26d3-738e-7a6929a5a7c9",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020426-CVE-2026-23094-9cb7@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:49Z",
        "headline": "CVE-2026-23094: uacce: fix isolate sysfs check condition",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: uacce: fix isolate sysfs check condition uacce supports the device isolation feature. If the driver implements the isolate_err_threshold_read and isolate_err_threshold_write callback functions, uacce will create sysfs files now. Users can read and configure the isolation policy through sysfs. Currently, sysfs files are created as long as either...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020426-CVE-2026-23094-9cb7@gregkh/"
          ],
          "content_hash": "sha256:2efbea3ba87c0db8c253165ac4f81f3bcec5f54f8d50b8f2b4c828d2e42553bd"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:70b0c580-0002-8b03-3dec-5290311a08cd",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020426-CVE-2026-23093-db0d@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:46Z",
        "headline": "CVE-2026-23093: ksmbd: smbd: fix dma_unmap_sg() nents",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: ksmbd: smbd: fix dma_unmap_sg() nents The dma_unmap_sg() functions should be called with the same nents as the dma_map_sg(), not the value the map function returned. The Linux kernel CVE team has assigned CVE-2026-23093 to this issue. Affected and fixed versions =========================== Issue introduced in 5.15 with commit...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020426-CVE-2026-23093-db0d@gregkh/"
          ],
          "content_hash": "sha256:0c8e6645fbce14c096b6a684e162d448a51541db2a99d7ea2aba9a6788174fdc"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:b9c65b48-4a0f-dcd4-da28-151f10ded2f9",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020425-CVE-2026-23092-fc15@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:42Z",
        "headline": "CVE-2026-23092: iio: dac: ad3552r-hs: fix out-of-bound write in ad3552r_hs_write_data_source",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: iio: dac: ad3552r-hs: fix out-of-bound write in ad3552r_hs_write_data_source When simple_write_to_buffer() succeeds, it returns the number of bytes actually copied to the buffer. The code incorrectly uses 'count' as the index for null termination instead of the actual bytes copied. If count exceeds the buffer size, this leads to out-of-bounds write. Add a...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020425-CVE-2026-23092-fc15@gregkh/"
          ],
          "content_hash": "sha256:be98e783ae77ddf8df0a6a9e3ccd99e9908594d25311ab9a0be4572e4408ba49"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:e1d10f51-350e-c3f0-c478-52c7e2a51cdd",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020431-CVE-2026-23110-56b1@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:39Z",
        "headline": "CVE-2026-23110: scsi: core: Wake up the error handler when final completions race against each other",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: scsi: core: Wake up the error handler when final completions race against each other The fragile ordering between marking commands completed or failed so that the error handler only wakes when the last running command completes or times out has race conditions. These race conditions can cause the SCSI layer to fail to wake the error handler, leaving I/O...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020431-CVE-2026-23110-56b1@gregkh/"
          ],
          "content_hash": "sha256:6ada885ca95ec7135978568dad5b10e37fce00e12283c236c3b522a85852db0c"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:5f4f61d1-34f4-421c-67fe-dea9865a9e2b",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020431-CVE-2026-23109-3e57@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:35Z",
        "headline": "CVE-2026-23109: fs/writeback: skip AS_NO_DATA_INTEGRITY mappings in wait_sb_inodes()",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: fs/writeback: skip AS_NO_DATA_INTEGRITY mappings in wait_sb_inodes() Above the while() loop in wait_sb_inodes(), we document that we must wait for all pages under writeback for data integrity. Consequently, if a mapping, like fuse, traditionally does not have data integrity semantics, there is no need to wait at all; we can simply skip these inodes. This...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020431-CVE-2026-23109-3e57@gregkh/"
          ],
          "content_hash": "sha256:f06b8cb15a1beb68f7f7012aa98e86b2686c28d09129adb0ff854c3afdef4864"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:d1a4f12c-4bae-996c-d3fc-4ef293fca335",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020425-CVE-2026-23091-4580@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:32Z",
        "headline": "CVE-2026-23091: intel_th: fix device leak on output open()",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: intel_th: fix device leak on output open() Make sure to drop the reference taken when looking up the th device during output device open() on errors and on close(). Note that a recent commit fixed the leak in a couple of open() error paths but not all of them, and the reference is still leaking on successful open(). The Linux kernel CVE team has assigned...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020425-CVE-2026-23091-4580@gregkh/"
          ],
          "content_hash": "sha256:26879a10e20772eb1af975013855e633d42cc4e6a0125e46cdc2ed4b710c7db7"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:03338573-eab0-5502-4b33-acb5419f9fe4",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020431-CVE-2026-23108-0550@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:28Z",
        "headline": "CVE-2026-23108: can: usb_8dev: usb_8dev_read_bulk_callback(): fix URB memory leak",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: can: usb_8dev: usb_8dev_read_bulk_callback(): fix URB memory leak Fix similar memory leak as in commit 7352e1d5932a (\"can: gs_usb: gs_usb_receive_bulk_callback(): fix URB memory leak\"). In usb_8dev_open() -> usb_8dev_start(), the URBs for USB-in transfers are allocated, added to the priv->rx_submitted anchor and submitted. In the complete callback...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020431-CVE-2026-23108-0550@gregkh/"
          ],
          "content_hash": "sha256:28eee77819fc9b55eb1e6091ecaee8bb13f27b5fa2c87d0c4623f2b50e60ca27"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:df879019-9ede-5a95-a959-90924862fe72",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020430-CVE-2026-23107-50d8@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:25Z",
        "headline": "CVE-2026-23107: arm64/fpsimd: signal: Allocate SSVE storage when restoring ZA",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: arm64/fpsimd: signal: Allocate SSVE storage when restoring ZA The code to restore a ZA context doesn't attempt to allocate the task's sve_state before setting TIF_SME. Consequently, restoring a ZA context can place a task into an invalid state where TIF_SME is set but the task's sve_state is NULL. In legitimate but uncommon cases where the ZA signal context...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020430-CVE-2026-23107-50d8@gregkh/"
          ],
          "content_hash": "sha256:e8fa6f36516aa0ed895ecc14b811b22fbbc053188123f90ab7ee24249088bb86"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:10afa447-80f3-0d9e-1f9f-ab6d05aa06f6",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020430-CVE-2026-23106-3edb@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:22Z",
        "headline": "CVE-2026-23106: timekeeping: Adjust the leap state for the correct auxiliary timekeeper",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: timekeeping: Adjust the leap state for the correct auxiliary timekeeper When __do_ajdtimex() was introduced to handle adjtimex for any timekeeper, this reference to tk_core was not updated. When called on an auxiliary timekeeper, the core timekeeper would be updated incorrectly. This gets caught by the lock debugging diagnostics because the timekeepers...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020430-CVE-2026-23106-3edb@gregkh/"
          ],
          "content_hash": "sha256:4c9b66acb6b740b880df9e79af7fb302e71999170f1c7ed296cb900a0ee6fb1b"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:adbe9d9a-1a3a-8d34-ef21-1352a1da0a1e",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020430-CVE-2026-23105-1d6d@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:17Z",
        "headline": "CVE-2026-23105: net/sched: qfq: Use cl_is_active to determine whether class is active in qfq_rm_from_ag",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: net/sched: qfq: Use cl_is_active to determine whether class is active in qfq_rm_from_ag This is more of a preventive patch to make the code more consistent and to prevent possible exploits that employ child qlen manipulations on qfq. use cl_is_active instead of relying on the child qdisc's qlen to determine class activation. The Linux kernel CVE team has...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020430-CVE-2026-23105-1d6d@gregkh/"
          ],
          "content_hash": "sha256:61c7c7c7b73061f4fc8e58364b030514106917784cee85b71068ad7976231786"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:c7812cfd-b9c3-5c92-5178-f2e05c62bcc1",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020429-CVE-2026-23104-3802@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:14Z",
        "headline": "CVE-2026-23104: ice: fix devlink reload call trace",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: ice: fix devlink reload call trace Commit 4da71a77fc3b (\"ice: read internal temperature sensor\") introduced internal temperature sensor reading via HWMON. ice_hwmon_init() was added to ice_init_feature() and ice_hwmon_exit() was added to ice_remove(). As a result if devlink reload is used to reinit the device and then the driver is removed, a call trace can...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020429-CVE-2026-23104-3802@gregkh/"
          ],
          "content_hash": "sha256:0746f9288ac72197958e18f57cd64ab02195276b5952db3b6e9517d4fffea642"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:32b95ef5-aa53-c930-e32b-d876827d40c7",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020429-CVE-2026-23103-63b3@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:11Z",
        "headline": "CVE-2026-23103: ipvlan: Make the addrs_lock be per port",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: ipvlan: Make the addrs_lock be per port Make the addrs_lock be per port, not per ipvlan dev. Initial code seems to be written in the assumption, that any address change must occur under RTNL. But it is not so for the case of IPv6. So 1) Introduce per-port addrs_lock. 2) It was needed to fix places where it was forgotten to take lock...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020429-CVE-2026-23103-63b3@gregkh/"
          ],
          "content_hash": "sha256:71032ee97f458f4ed7e44b957ba08d007a87214a344a2598954a64af51b214db"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:e14b5388-e9d9-3a68-2ed0-2d6f08e34342",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020429-CVE-2026-23102-bafe@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:06Z",
        "headline": "CVE-2026-23102: arm64/fpsimd: signal: Fix restoration of SVE context",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: arm64/fpsimd: signal: Fix restoration of SVE context When SME is supported, Restoring SVE signal context can go wrong in a few ways, including placing the task into an invalid state where the kernel may read from out-of-bounds memory (and may potentially take a fatal fault) and/or may kill the task with a SIGKILL. (1) Restoring a context with...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020429-CVE-2026-23102-bafe@gregkh/"
          ],
          "content_hash": "sha256:efb979c2466da20706245b81865e44468f1a1817bfe1626df5df4d9ecbb5339a"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:02fe222a-1266-e2e4-d612-4020c7fe25e8",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020428-CVE-2026-23101-47e0@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:21:03Z",
        "headline": "CVE-2026-23101: leds: led-class: Only Add LED to leds_list when it is fully ready",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: leds: led-class: Only Add LED to leds_list when it is fully ready Before this change the LED was added to leds_list before led_init_core() gets called adding it the list before led_classdev.set_brightness_work gets initialized. This leaves a window where led_trigger_register() of a LED's default trigger will call led_trigger_set() which calls...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020428-CVE-2026-23101-47e0@gregkh/"
          ],
          "content_hash": "sha256:34a336c2f69e6e670b67beeb198064996c4fbbb78a6074009eae5185417264a4"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:70d08665-65e5-9af0-82d7-a815a661cd7d",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020428-CVE-2026-23100-b482@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:20:59Z",
        "headline": "CVE-2026-23100: mm/hugetlb: fix hugetlb_pmd_shared()",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: mm/hugetlb: fix hugetlb_pmd_shared() Patch series \"mm/hugetlb: fixes for PMD table sharing (incl. using mmu_gather)\", v3. One functional fix, one performance regression fix, and two related comment fixes. I cleaned up my prototype I recently shared [1] for the performance fix, deferring most of the cleanups I had in the prototype to a later point. While...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020428-CVE-2026-23100-b482@gregkh/"
          ],
          "content_hash": "sha256:7d078bd6bb5d5cf16df9d45234435f3a6dfc6b183b70fb584c55c22dbe7e0b9e"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:430c684e-fc89-56f1-dcfa-3dfa5fd7f35b",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020428-CVE-2026-23099-a393@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:20:56Z",
        "headline": "CVE-2026-23099: bonding: limit BOND_MODE_8023AD to Ethernet devices",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: bonding: limit BOND_MODE_8023AD to Ethernet devices BOND_MODE_8023AD makes sense for ARPHRD_ETHER only. syzbot reported: BUG: KASAN: global-out-of-bounds in __hw_addr_create net/core/dev_addr_lists.c:63 [inline] BUG: KASAN: global-out-of-bounds in __hw_addr_add_ex+0x25d/0x760 net/core/dev_addr_lists.c:118 Read of size 16 at addr ffffffff8bf94040 by task...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020428-CVE-2026-23099-a393@gregkh/"
          ],
          "content_hash": "sha256:a346ed2e7b5b07308f2900478c876ac9ff6cd348fcbed5db8edc529b5488c152"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:85673643-6ed5-68bd-4d89-2b72ee4c9cac",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020425-CVE-2026-23090-2971@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:20:53Z",
        "headline": "CVE-2026-23090: slimbus: core: fix device reference leak on report present",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: slimbus: core: fix device reference leak on report present Slimbus devices can be allocated dynamically upon reception of report-present messages. Make sure to drop the reference taken when looking up already registered devices. Note that this requires taking an extra reference in case the device has not yet been registered and has to be allocated. The...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020425-CVE-2026-23090-2971@gregkh/"
          ],
          "content_hash": "sha256:6155e7a8ec0a77b669bb08661ff46a96be14205c36dc2085393298d1cc789797"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:c02d6096-cf14-2893-184a-aaf756792ab0",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020415-CVE-2026-23062-991d@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:20:50Z",
        "headline": "CVE-2026-23062: platform/x86: hp-bioscfg: Fix kernel panic in GET_INSTANCE_ID macro",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: platform/x86: hp-bioscfg: Fix kernel panic in GET_INSTANCE_ID macro The GET_INSTANCE_ID macro that caused a kernel panic when accessing sysfs attributes: 1. Off-by-one error: The loop condition used '<=' instead of '<', causing access beyond array bounds. Since array indices are 0-based and go from 0 to instances_count-1, the loop should use '<'. 2. Missing...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020415-CVE-2026-23062-991d@gregkh/"
          ],
          "content_hash": "sha256:54a218d04346dc442f3aef6f03e963e651558b53ab6bb5bfef14e27669d11ef8"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:d397dfee-feac-fc48-9c21-39c5ba7ccb3f",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020415-CVE-2026-23061-31be@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:20:46Z",
        "headline": "CVE-2026-23061: can: kvaser_usb: kvaser_usb_read_bulk_callback(): fix URB memory leak",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: can: kvaser_usb: kvaser_usb_read_bulk_callback(): fix URB memory leak Fix similar memory leak as in commit 7352e1d5932a (\"can: gs_usb: gs_usb_receive_bulk_callback(): fix URB memory leak\"). In kvaser_usb_set_{,data_}bittiming() -> kvaser_usb_setup_rx_urbs(), the URBs for USB-in transfers are allocated, added to the dev->rx_submitted anchor and submitted. In...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020415-CVE-2026-23061-31be@gregkh/"
          ],
          "content_hash": "sha256:a3e96d588e93584bfa36366c6eb28bdc31bdfd772364fb47ede1b388c4c2b947"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      },
      {
        "source": "linux_kernel_cve",
        "id": "urn:uuid:2b1cffbd-b949-2f8a-d05d-93fd0469d950",
        "url": "https://lore.kernel.org/linux-cve-announce/2026020414-CVE-2026-23060-6a41@gregkh/",
        "published_at": "2026-02-06T03:41:59Z",
        "updated_at": "2026-02-04T16:20:43Z",
        "headline": "CVE-2026-23060: crypto: authencesn - reject too-short AAD (assoclen<8) to match ESP/ESN spec",
        "content": {
          "excerpt_text": "From: Greg Kroah-Hartman <gregkh@kernel.org> Description =========== In the Linux kernel, the following vulnerability has been resolved: crypto: authencesn - reject too-short AAD (assoclen<8) to match ESP/ESN spec authencesn assumes an ESP/ESN-formatted AAD. When assoclen is shorter than the minimum expected length, crypto_authenc_esn_decrypt() can advance past the end of the destination scatterlist and trigger a NULL pointer dereference in scatterwalk_map_and_copy(), leading to a kernel...",
          "lang": "en"
        },
        "provenance": {
          "fetched_at": "2026-02-06T03:41:59Z",
          "evidence_urls": [
            "https://lore.kernel.org/linux-cve-announce/2026020414-CVE-2026-23060-6a41@gregkh/"
          ],
          "content_hash": "sha256:c46f24b48072fcbb537ce0d122b6dc0e3856c97677a73fe4b32574808fd2f733"
        },
        "risk": {
          "score": 0.0,
          "reasons": []
        }
      }
    ],
    "updated": [],
    "removed": [],
    "flagged": []
  },
  "counts": {
    "new": 25,
    "updated": 0,
    "removed": 0,
    "flagged": 0
  },
  "integrity_reset": true,
  "integrity_risk": 0.2,
  "archive_url": "/archive/linux_kernel_cve/2026/02/06/20260206T034159Z_f5a41ca8b933908a.json"
}
